rem ----------------------------------------------------------------------
rem PonyCraft
rem ----------------------------------------------------------------------
rem This game is based on the show "My Little Pony - Friendship is Magic"
rem ----------------------------------------------------------------------
rem Author                    : TheComet (Alex Murray)
rem Programmer                : TheComet (Alex Murray)
rem Start Date                : 06. March 2012
rem End Date                  : 
rem ----------------------------------------------------------------------

rem ----------------------------------------------------------------------
rem Initial setups
rem ----------------------------------------------------------------------

rem screen dimensions
global scw as integer
global sch as integer

rem maximum display size with 4:3
perform checklist for display modes
scw = 0
sch = 0
for r = 1 to checklist quantity()
	if scw < checklist value a(r)
		if checklist value a(r)*3 = checklist value b(r)*4
			scw = checklist value a(r)
			sch = checklist value b(r)
		endif
	endif
next r

rem setup screen
set display mode scw , sch , 32
sync on
sync rate 0
backdrop on
color backdrop 0
show mouse
autocam off

rem ----------------------------------------------------------------------
rem Constants
rem ----------------------------------------------------------------------

rem game speed
#constant GameFPS                   60

rem images
#constant IMGBlack                  1
#constant IMGWhite                  2
#constant IMGUnitSelectFriendly     3
#constant IMGUnitSelectNeutral      4
#constant IMGUnitSelectHostile      5
#constant IMGFlutterShyALotOfCode   6
#constant IMGClickObjConnection     7

rem effects
#constant ParallaxMappingFX         1

rem ----------------------------------------------------------------------
rem User Defined Types
rem ----------------------------------------------------------------------

rem vectors
type vec2
   int x                            as integer
   int y                            as integer
endtype

type vec3
   x#                               as float
   y#                               as float
   z#                               as float
endtype

rem timer based movement
type TBMVT
   CurrentTime                      as float
   LastTime#                        as float
   Delta#                           as float
endtype

rem controls
type CTRLVT
	Animation                        as integer
	Camera                           as integer
	ClickObj                         as integer
   Console                          as integer
   Distortion                       as integer
	GUI                              as integer
	MagicMissile                     as integer
   Menu                             as integer
   Message                          as integer
   Mouse                            as integer
	Script                           as integer
	Slider                           as integer
	TeleportEffect                   as integer
   TextEntry                        as integer
	Trigger                          as integer
	Unit                             as integer
	UnitBoxSelect                    as integer
	World                            as integer
endtype

rem misc data
type MiscVT
	pos2D										as vec2
endtype

rem ----------------------------------------------------------------------
rem Global Variables
rem ----------------------------------------------------------------------

rem control enables
global CTRL as CTRLVT

rem timer based movement
global TBM as TBMVT

rem misc data
global Misc as MiscVT

rem global font
global FontID as integer
FontID = a2CreateFont("ariel", 14, a2Size_Char(), a2Style_Normal())

rem some global vectors
r = make vector3(1)
r = make vector4(2)

rem ----------------------------------------------------------------------
rem Global Arrays
rem ----------------------------------------------------------------------

rem for resizing multidimensional arrays
rem It's type can change at any time
dim ResizeArray() as PathfinderAAAT

rem ----------------------------------------------------------------------
rem Initialise
rem ----------------------------------------------------------------------

rem game controls
CTRL.Animation                      = 1
CTRL.Camera                         = 1
CTRL.ClickObj                       = 1
CTRL.Console                        = 1
CTRL.Distortion                     = 1
CTRL.GUI                            = 1
CTRL.MagicMissile                   = 1
CTRL.Menu                           = 1
CTRL.Message                        = 1
CTRL.Mouse                          = 1
CTRL.Script                         = 1
CTRL.Slider                         = 1
CTRL.TeleportEffect                 = 1
CTRL.TextEntry                      = 1
CTRL.Trigger                        = 1
CTRL.Unit                           = 1
CTRL.UnitBoxSelect                  = 1
CTRL.World                          = 1

rem enable debugging
InitConsole()
InitDebug()

rem initialise game elements
InitAnimation()
InitCamera()
InitClickObj()
InitDistortion()
InitGUI()
InitMagicMissile()
InitMenu()
InitMessage()
InitMouse()
InitScript()
InitTeleportEffect()
InitTextEntry()
InitTrigger()
InitUnit()
InitUnitBoxSelect()
InitWorld()

rem ----------------------------------------------------------------------
rem Load Media
rem ----------------------------------------------------------------------

rem images to be used for game mechanics
LoadImage( "media\images\core\black.bmp",                            IMGBlack                       )
LoadImage( "media\images\core\white.bmp",                            IMGWhite                       )
LoadImage( "media\objects\clickobj\connection.png",                  IMGClickObjConnection          )
LoadImage( "media\images\console\Fluttershylotofcode.png",           IMGFlutterShyALotOfCode        )
LoadImage( "media\images\unitselect\friendly.png",                   IMGUnitSelectFriendly          )
LoadImage( "media\images\unitselect\neutral.png",                    IMGUnitSelectNeutral           )
LoadImage( "media\images\unitselect\hostile.png",                    IMGUnitSelectHostile           )

rem effects
LoadEffect( "media\FX\ParallaxMapping.fx",                           ParallaxMappingFX              )

rem ----------------------------------------------------------------------
rem Main Loop
rem ----------------------------------------------------------------------

rem debugging info
DebugOutput( 1 , "Done Loading, Executing StartupScrip.txt -------------------------------" )
Debug.refresh = 0
Console.active = 0

rem run startup script
LoadScript( "scripts\StartupScript.txt" , 0 )
RunScript( 0 )
TriggerSetTimers()

rem turn debug refreshing off
DebugOutput( 1 , "Entering Game Loop -------------------------------" )
Debug.refresh = 0
Console.active = 0

rem console help
AddTextToConsole( "Welcome to the PonyCraft Console!" , 0xFF00FF00 , 0 )
AddTextToConsole( "Press <insert> to enter commands" , 0xFF00FFFF , 0 )
AddTextToConsole( "Press <instert> again to hide console" , 0xFF00FFFF , 0 )
AddTextToConsole( "Enter "+chr$(34)+"Help"+chr$(34)+" for a list of commands" , 0xFF00FFFF , 0 )

rem ----------------------------------------------------------------------------------

rem start of main loop
TBM.CurrentTime = hitimer(1000)
do
	
	a2text FontID , 0,0,"wat",0xFFFFFFFF

   rem control timer based movement
   TBM.LastTime# = TBM.CurrentTime
   TBM.CurrentTime = hitimer(1000)
   TBM.Delta# = curvevalue( (TBM.CurrentTime - TBM.LastTime#) / GameFPS , TBM.Delta# , 2 )
	
	remstart
	for n = 0 to 1
		print "active: ";Unit(n).Active
		print "ability active: ";Unit(n).Ability.Active
		print "follow: ";Unit(n).FollowUnit
		print "clickobj count: ";Unit(n).CurrentMaxPath
		for t = 0 to Unit(n).CurrentMaxPath
			print "clickobj ID(";t;"): ";UnitPath(n,t,0).ClickObjID
		next t
		
		print "====================="
	next n
	remend
   
	rem control game elements
   ControlGameElements()
	
	rem Advanced 2D fix
   a2setlineAA 0

   rem refresh screen
   sync

rem end of main loop
loop

rem end program
end

rem ----------------------------------------------------------------------
rem Subroutines
rem ----------------------------------------------------------------------



rem ----------------------------------------------------------------------
rem Functions
rem ----------------------------------------------------------------------

function ControlGameElements()

   rem reset cursor
   set cursor 0 , 0
	
	rem screen fps
	print "Screen FPS: ";screen fps()
	
	rem distortion object
	hide object 1001
	
	rem higher functionality elements
	if CTRL.Mouse                    = 1 then ControlMouse()
	if CTRL.TextEntry                = 1 then ControlTextEntry()

   rem control game elements
	if CTRL.Animation                = 1 then ControlAnimation()
	if CTRL.Camera                   = 1 then ControlCamera()
	if CTRL.ClickObj                 = 1 then ControlClickObj()
   if CTRL.Distortion               = 1 then ControlDistortion()
	if CTRL.GUI                      = 1 then ControlGUI()
	if CTRL.MagicMissile             = 1 then ControlMagicMissile()
   if CTRL.Menu                     = 1 then ControlMenu()
   if CTRL.Message                  = 1 then ControlMessage()
	if CTRL.Script                   = 1 then ControlScript()
	if CTRL.Slider                   = 1 then ControlSlider()
	if CTRL.TeleportEffect           = 1 then ControlTeleportEffect()
	if CTRL.Trigger                  = 1 then ControlTrigger()
	if CTRL.Unit                     = 1 then ControlUnit()
	if CTRL.UnitBoxSelect            = 1 then ControlUnitBoxSelect()
	if CTRL.World                    = 1 then ControlWorld()
	
	rem higher drawing priority elements
	if CTRL.Console                  = 1 then ControlConsole()
	
	rem distortion object
	show object 1001
	texture object 1001,1001

endfunction

function customABS( value# )
	if value# > 0 then exitfunction value#
	value# = 0 - value#
endfunction value#

function SetObjectDiffuse( Obj , color )
	
	rem local variables
	local i as integer
	local limb as integer
	
	rem edit diffuse data of each vertex
	perform checklist for object limbs Obj
	for limb = 0 to checklist quantity() - 1
		lock vertexdata for limb Obj , limb
			for i = 0 to get vertexdata vertex count() - 1
				set vertexdata diffuse i , (get vertexdata diffuse(i) && 0xFF000000) || (color && 0x00FFFFFF)
			next i
		unlock vertexdata
	next limb
	
endfunction

function ConvertObjectFVFTo338( Obj )
	
	rem local variables
	local i as integer
	local limb as integer
	
	rem convert
	convert object fvf Obj , 338
	
	rem edit diffuse data of each vertex to be white
	perform checklist for object limbs Obj
	for limb = 0 to checklist quantity() - 1
		lock vertexdata for limb Obj , limb
			for i = 0 to get vertexdata vertex count() - 1
				set vertexdata diffuse i , 0xFFFFFFFF
			next i
		unlock vertexdata
	next limb
	
endfunction

function ObjectInScreen( Obj )
	
	rem local variables
	local x as integer
	local y as integer
	
	rem get screen coordinates
	x = object screen x( Obj )
	y = object screen y( Obj )
	
	rem if screen coordinates are on screen then return success
	if x > 0 and x < scw and y > 0 and y < sch then exitfunction 1
	
endfunction 0

rem ----------------------------------------------------------------------
rem Data Statements
rem ----------------------------------------------------------------------



remstart
------------------------------------------------------
3D rotation matrices
------------------------------------------------------
        / 1        0        0        \
Rx(a) = | 0        cos(a)   -sin(a)  |
        \ 0        sin(a)   cos(a)   /

        / cos(a)   0        -sin(a)  \
Ry(a) = | 0        1        0        |
        \ sin(a)   0        cos(a)   /

        / cos(a)   -sin(a)  0        \
Rz(a) = | sin(a)   cos(a)   0        |
        \ 0        0        1        /
------------------------------------------------------
remend
rem -----------------------------------------------------------
rem Debug
rem by TheComet
rem -----------------------------------------------------------

type DebugVT
   refresh     as integer
endtype

function InitDebug()

   rem local variables
   local Logfile$ as string
   local lastrun$ as string

   rem global variables
   global Debug as DebugVT

   rem specify log file
   if path exist( "logs" ) = 0 then make directory "logs"
   Logfile$="logs\DebugLog.html"

   rem get date last run
   set dir "logs"
   find first
   find next
   lastrun$=get file date$()
   set dir ".."

   ` Open the log file
   if file exist(Logfile$) then delete file Logfile$
   OPEN LOG Logfile$, 1

   ` Enable logging against a tag even if the tag is unknown
   SET LOG UNKNOWN TAG 1

   ` Set up the severity tags
   SET LOG TAG 0 , "<font color=#000000>", "</font><br>" : rem this is the INFO level
   SET LOG TAG 1 , "<font color=#0000ff>", "</font><br>": rem NOTICE level
   SET LOG TAG 2 , "<font color=#808080>", "</font><br>": rem WARN level
   SET LOG TAG 3 , "<font color=#ff8080>", "</font><br>": rem ERROR level
   SET LOG TAG 4 , "<font color=#ff0000>", "</font><br>": rem DISASTER level

   ` Write out a html header
   WRITELN LOG "<html><body>"
   WRITELN LOG "============================================<br>"
   WRITELN LOG "PonyCraft - Debug Output<br>"
   WRITELN LOG "============================================<br>"
   WRITELN LOG "<br>"

   ` Write out system details
   WRITELN LOG 0 , "Last run : "+lastrun$
   WRITELN LOG 0 , ""
   WRITELN LOG 0 , "System Info ---------------------------------------"
   WRITELN LOG 0 , ""
   WRITELN LOG 0 , CURRENT GRAPHICS CARD$()
   WRITELN LOG 0 , "System BIOS version   : "+get registry$("HARDWARE\DESCRIPTION\System","SystemBiosVersion")
   WRITELN LOG 0 , "System BIOS date      : "+get registry$("HARDWARE\DESCRIPTION\System","SystemBiosDate")
   WRITELN LOG 0 , "Central processor     : "+get registry$("HARDWARE\DESCRIPTION\System\CentralProcessor\0","Identifier")
   WRITELN LOG 0 , "Processor name        : "+get registry$("HARDWARE\DESCRIPTION\System\CentralProcessor\0","ProcessorNameString")
   WRITELN LOG 0 , "Processor frequency   : "+str$(get registry("HARDWARE\DESCRIPTION\System\CentralProcessor\0","~MHz"))+" MHz"
   WRITELN LOG 0 , "Video BIOS version    : "+get registry$("HARDWARE\DESCRIPTION\System","VideoBiosVersion")
   WRITELN LOG 0 , "Video BIOS date       : "+get registry$("HARDWARE\DESCRIPTION\System","VideoBiosDate")
   WRITELN LOG 0 , "Running at resolution : "+str$(screen width())+"x"+str$(screen height())+"x"+str$(screen depth())
   WRITELN LOG 0 , "Directory             : "+get dir$()
   WRITELN LOG 0 , ""
   WRITELN LOG 0 , "---------------------------------------------------"
   WRITELN LOG 0 , ""

   rem debug has started
   DebugOutput(0,"Debugging Started")

endfunction

function DebugOutput(level,message$)

   rem local variables
   local color as dword

   rem log in log file
   date$ = get date$()
   time$ = get time$()
   msg$ = "["+date$ + " " + time$ + "] " + message$
   WRITELN LOG level , msg$
   
   rem set colour according to level of severity
   select level
      case 0 : color = 0xFFFFFFFF : endcase
      case 1 : color = 0xFF0020FF : endcase
      case 2 : color = 0xFFFFFF00 : endcase
      case 3 : color = 0xFFFF8000 : endcase
      case 4 : color = 0xFFFF0000 : endcase
   endselect
   
   rem log in console
   AddTextToConsole( message$ , color , level )

endfunction

function LoadObject(filename$,obj)

   DebugOutput(0,"Loading Object "+chr$(34)+filename$+chr$(34)+", index : "+str$(obj))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load object filename$,obj

endfunction

function LoadImage(filename$,img)

   DebugOutput(0,"Loading Image "+chr$(34)+filename$+chr$(34)+", index : "+str$(img))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load image filename$,img

endfunction

function LoadSound(filename$,snd)

   DebugOutput(0,"Loading Sound "+chr$(34)+filename$+chr$(34)+", index : "+str$(snd))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load sound filename$,snd

endfunction

function LoadMusic(filename$,msc)

   DebugOutput(0,"Loading Music "+chr$(34)+filename$+chr$(34)+", index : "+str$(msc))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load music filename$,msc

endfunction

function LoadBitmap(filename$,bmp)

   DebugOutput(0,"Loading Bitmap "+chr$(34)+filename$+chr$(34)+", index : "+str$(bmp))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load image filename$,bmp

endfunction

function LoadEffect(filename$,fx)

   DebugOutput(0,"Loading Effect "+chr$(34)+filename$+chr$(34)+", index : "+str$(fx))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load effect filename$,fx,0

endfunction

function LoadCameraEffect(filename$,fx)

   DebugOutput(0,"Loading Camera Effect "+chr$(34)+filename$+chr$(34)+", index : "+str$(fx))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!")
   load camera effect filename$,fx,0

endfunction

function OpenToRead(file,filename$)

   DebugOutput(0,"Opening file (read)"+chr$(34)+filename$+chr$(34)+", index : "+str$(file))
   if file exist(filename$)=0 then DebugOutput(3,"File "+chr$(34)+filename$+chr$(34)+" does not exist!"):exitfunction -1
   open to read file,filename$

endfunction 0

function OpenToWrite(file,filename$)

   DebugOutput(0,"Opening file (write)"+chr$(34)+filename$+chr$(34)+", index : "+str$(file))
   if file exist(filename$)=1 then DebugOutput(2,"File "+chr$(34)+filename$+chr$(34)+" already exists! Overwriting..."):delete file filename$
   open to write file,filename$

endfunction
rem ---------------------------------------------------------------------------
rem Console
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant ConsoleTextMax                     100
#constant ConsoleArgMax                      20

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type ConsoleVT
   Active                                    as integer
   pos                                       as vec2
   size                                      as vec2
   toggle                                    as integer
   ForceOutput                               as integer
	Resize												as integer
	Move													as integer
endtype

type ConsoleTextAT
   Color                                     as dword
   Text$                                     as string
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitConsole()

   rem ---------------------------------------------------------------------------
   rem Global Variables
   rem ---------------------------------------------------------------------------

   global Console                              as ConsoleVT

   rem ---------------------------------------------------------------------------
   rem Global Arrays
   rem ---------------------------------------------------------------------------

   global dim ConsoleText( ConsoleTextMax )    as ConsoleTextAT
   global dim ConsoleArg$( ConsoleArgMax )     as string
   
   rem set initial values
   Console.Active = 0
   Console.pos.x = 10
   Console.pos.y = 10
   Console.size.x = 600
   Console.size.y = 600

endfunction

function ControlConsole()

   rem insert key will switch between different active states
   rem 0 means it's invisible (inactive)
   rem 1 means it's visible, but you can't type anything into it
   rem 2 means it's visible and you can type things into it
   if keystate(210)
      if Console.Toggle = 0
         Console.Toggle = 1
         
         rem change active states
         inc Console.Active
         if Console.Active > 2 then Console.Active = 0
         
         rem if console is ready to accept text, reset entry buffer
         if Console.Active = 2 then ClearTextEntry()
         
      endif
   else
      Console.Toggle = 0
   endif
   
   rem if the active state is larger than 0, draw console to the screen
   if Console.Active > 0
      
      rem draw frame
      a2fillbox Console.pos.x , Console.pos.y , Console.pos.x + Console.size.x , Console.pos.y + Console.size.y , 0xC0000000
      a2box Console.pos.x , Console.pos.y , Console.pos.x + Console.size.x , Console.pos.y + Console.size.y , 0xFFFFFFFF
      a2line Console.pos.x , Console.pos.y + Console.size.y - 20 , Console.pos.x + console.size.x , Console.pos.y + Console.size.y - 20 , 0xFFFFFFFF
   
      rem draw text to console
      for n = 0 to ConsoleTextMax
         if n*15 < Console.size.y - 40
            a2text FontID , Console.pos.x+3 , Console.pos.y + Console.size.y - 40 - (n*15) , ConsoleText( n ).text$ , ConsoleText( n ).color
			endif
      next n
   
   endif
   
   rem check if the console is ready to accept text
   if Console.Active = 2
		
   
      rem light up input box
      a2fillbox Console.pos.x+1 , Console.pos.y + Console.size.y - 19 , Console.pos.x + Console.size.x-1 , Console.pos.y + Console.size.y-1 , 0x50FFFF00
      
      rem print user input
      a2text FontID , Console.pos.x+3 , Console.pos.y + Console.size.y-19 , GetTextEntryWithCursor() , 0xFFFFFFFF
      
      rem enter text into console
      if returnkey()
         if GetTextEntry() <> ""
         
            rem process it
            ProcessEntry( CompileEntry(GetTextEntry(),-1,0) , 0 )
            ClearTextEntry()
            
         endif
      endif
      
   endif

endfunction

function AddTextToConsole( text$ , color , flag )

   remstart
   ----------------------------------------------------------
   Flags
   0 - INFO
   1 - NOTICE
   2 - WARNING
   3 - ERROR
   4 - DISASTER
   5 - USER (Text entered by the user)
   ----------------------------------------------------------
   remend
   
   rem local variables
   local n as integer
   local flag$ as string
   
   rem shift text stack to make room for new line of text
   for n = ConsoleTextMax to 1 step -1
      ConsoleText( n ).text$ = ConsoleText( n - 1 ).text$
      ConsoleText( n ).color = ConsoleText( n - 1 ).color
   next n
   
   rem create flag
   select flag
      case 0 : flag$ = "[INFO] " : endcase
      case 1 : flag$ = "[NOTICE] " : endcase
      case 2 : flag$ = "[WARNING] " : endcase
      case 3 : flag$ = "[ERROR] " : endcase
      case 4 : flag$ = "[DISASTER] " : endcase
      case 5 : flag$ = "[USER] " : endcase
   endselect
   
   rem now slot 0 is ready to be overwritten
   ConsoleText( 0 ).text$ = flag$ + text$
   ConsoleText( 0 ).color = color
   
   rem force output to debug log
   if Console.ForceOutput = 1
   
      rem log in log file
      date$ = get date$()
      time$ = get time$()
      msg$ = "["+date$ + " " + time$ + "] " + ConsoleText( 0 ).text$
      WRITELN LOG flag , msg$
      
   endif

endfunction
rem ---------------------------------------------------------------------------
rem Triggers
rem by TheComet
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type TriggerVT
   logging                                   as integer
	CurrentMax											as integer
endtype

type TriggerAT
   active                                    as integer
   pos                                       as vec3
   obj                                       as word
   radius#                                   as float
   toggle                                    as integer
   once                                      as integer
   script                                    as integer
	time                                      as integer
	resettime                                 as integer
	UnitID                                    as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialize
rem ---------------------------------------------------------------------------

function InitTrigger()

   DebugOutput( 0 , "Initializing Triggers" )

   rem ---------------------------------------------------------------------------
   rem Global variables
   rem ---------------------------------------------------------------------------

   global Trigger                            as TriggerVT

   rem ---------------------------------------------------------------------------
   rem Global Arrays
   rem ---------------------------------------------------------------------------

   global dim Trigger()            				as TriggerAT
	
	rem initial values
	Trigger.CurrentMax = -1

endfunction

function CreatePositionTrigger( x# , y# , z# , radius# , one_time_execute , script$ , ScriptIndex )
	
   rem logging
   if Trigger.logging = 1 then AddTextToConsole( "CreatePositionTrigger " + str$(x#) + "," + str$(y#) + "," + str$(z#) + "," + str$(radius#) + "," + chr$(34) + script$ + chr$(34) , 0xFF00FFFF , 0 )

	rem make sure script exists
   if file exist( script$ ) = 0
      AddTextToConsole("Script " + chr$(34) + script$ + chr$(34) + " does not exist" , 0xFFFF0000 , 3 )
      exitfunction -1
   endif

   rem load script
   if LoadScript( Script$ , ScriptIndex ) = -1
		if Trigger.logging = 1 then AddTextToConsole( "Unable to load script" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variables
   local n as integer
	
   rem find free slot
   for n = 0 to Trigger.CurrentMax
      if Trigger( n ).active < 2 then exit
   next n

   rem no free slot
   if n = Trigger.CurrentMax + 1
      array insert at bottom Trigger()
		inc Trigger.CurrentMax
   endif

   rem set values
   Trigger( n ).active       = 2
   Trigger( n ).pos.x#       = x#
   Trigger( n ).pos.y#       = y#
   Trigger( n ).pos.z#       = z#
   Trigger( n ).radius#      = radius#
   Trigger( n ).script       = ScriptIndex
   Trigger( n ).once         = one_time_execute

endfunction n

function CreateTimerTrigger( one_time_execute , time , script$ , scriptindex )
	
	rem logging
	if Trigger.logging = 1 then AddTextToConsole( "CreateTimerTrigger " + str$(one_time_execute) + "," + script$ + "," + str$(scriptindex) , 0xFF00FFFF , 0 )
	
	rem make sure script exists
	if file exist( script$ ) = 0
		if Trigger.logging = 1 then AddTextToConsole( "Script " + chr$(34) + script$ + chr$(34) + " does not exist!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem load script
	if LoadScript( script$ , scriptindex ) = -1
		if Trigger.logging = 1 then AddTextToConsole( "Unable to load script" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to Trigger.CurrentMax
		if Trigger( n ).Active < 2 then exit
	next n
	
	rem no free slot found, create
	if n = Trigger.CurrentMax + 1
		array insert at bottom Trigger()
		inc Trigger.CurrentMax
	endif
	
	rem set values
	Trigger( n ).Active = 3
	Trigger( n ).once = one_time_execute
	Trigger( n ).script = scriptindex
	Trigger( n ).time = timer() + time
	Trigger( n ).resettime = time
	
endfunction n

function CreateUnitTimerTrigger( UnitID , one_time_execute , time , script$ , ScriptIndex )
	
	rem logging
	if Trigger.logging = 1 then AddTextToConsole( "CreateUnitTimerTrigger " + str$(one_time_execute) + "," + str$(time) + "," + script$ + "," + str$(ScriptIndex) , 0xFF00FFFF , 0 )
	
	rem make sure script file exists
	if file exist( script$ ) = 0
		if Trigger.logging = 1 then AddTextToConsole( "Script " + chr$(34) + script$ + chr$(34) + " does not exist!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to Trigger.CurrentMax
		if Trigger( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = Trigger.CurrentMax + 1
		array insert at bottom Trigger()
		inc Trigger.CurrentMax
	endif
	
	rem load script
	LoadScript( script$ , ScriptIndex )
	
	rem set values
	Trigger( n ).Active = 4
	Trigger( n ).time = timer() + time
	Trigger( n ).resettime = time
	Trigger( n ).script = ScriptIndex
	Trigger( n ).once = one_time_execute
	Trigger( n ).UnitID = UnitID
	
endfunction n

function DestroyTrigger( n )
	
	rem debug
   if Trigger.logging = 1 then AddTextToConsole( "DestroyTrigger " + str$(n) , 0xFF00FFFF , 0 )

   rem if not active, exit
   if Trigger( n ).active < 2
      if Trigger.logging = 1 then AddTextToConsole( "Not Active!" , 0xFFFF0000 , 3 )
      exitfunction -1
   endif

   rem destroy trigger
   Trigger( n ).active = 0
	if Trigger( n ).obj > 0
		if object exist( Trigger( n ).obj ) then delete object Trigger( n ).obj
	endif
   Trigger( n ).obj = 0

endfunction n

function ShowTrigger( n )
	
	rem logging
   if Trigger.logging = 1 then AddTextToConsole( "ShowTrigger " + str$(n) , 0xFF00FFFF , 0 )

   rem if not active, exit
   if Trigger( n ).active <> 2
      if Trigger.logging = 1 then AddTextToConsole( "Does Not Exist!" , 0xFFFF0000 , 3 )
      exitfunction -1
   endif

   rem create sphere
   if Trigger( n ).obj = 0
      Trigger( n ).obj = find free object()
      make object sphere Trigger( n ).obj , Trigger( n ).radius#
      position object Trigger( n ).obj , Trigger( n ).pos.x# , Trigger( n ).pos.y# , Trigger( n ).pos.z#
      set object wireframe Trigger( n ).obj , 1
   endif

endfunction n

function ShowTriggers()

   rem local variables
   local n as integer

   rem show all triggers
   for n = 0 to Trigger.CurrentMax
      if Trigger( n ).Active = 2 then ShowTrigger( n )
   next n

endfunction

function HideTriggers()

   rem logging
   if Trigger.logging = 1 then AddTextToConsole( "HideTriggers" , 0xFF00FFFF , 0 )

   rem local variables
   local n as integer

   rem delete all objects
   for n = 0 to Trigger.CurrentMax
      if Trigger( n ).obj > 0
         if object exist( Trigger( n ).obj ) then delete object Trigger( n ).obj
         Trigger( n ).obj = 0
      endif
   next n

endfunction

function TriggerSetTimers()
	
	rem local variables
	local n as integer
	
	rem logging
	if Trigger.logging = 1 then AddTextToConsole( "Initialising trigger timers" , 0xFF00FFFF , 0 )
	
	rem loop through all triggers
	for n = 0 to Trigger.CurrentMax
		if Trigger( n ).Active > 1
			Trigger( n ).time = timer() + Trigger( n ).Resettime
		endif
	next n
	
endfunction

function ControlTrigger()

   rem local variables
   local n as integer
   local p as integer
   local success as integer

   rem loop through all active triggers
   for n = 0 to Trigger.CurrentMax
		
		rem position trigger
      if Trigger( n ).active = 2

         rem distance to player
         rem if dist#=(Player(p).pos.x#-Trigger(n).pos.x#)^2+(Player(p).pos.y#-Trigger(n).pos.y#)^2+(Player(p).pos.z#-Trigger(n).pos.z#)^2 < Trigger(n).radius#*Trigger(n).radius#
            if Trigger( n ).toggle=0
               Trigger( n ).toggle=1

               rem execute script
               RunScript( Trigger( n ).Script )

               rem if it's a one-time only trigger, destroy
               if Trigger( n ).once=1 then DestroyTrigger( n )
            endif
         rem else
            Trigger( n ).toggle=0
         rem endif
      endif
		
		rem timer trigger
		if Trigger( n ).active = 3
			
			rem check if time is up
			if Trigger( n ).time - timer() < 0
				
				rem execute script
				RunScript( Trigger( n ).Script )
				
				rem if it's a one time only trigger, destroy
				if Trigger( n ).once = 1
					DestroyTrigger( n )
					
				rem reset time
				else
					Trigger( n ).time = timer() + Trigger( n ).resettime
					
				endif
			
			endif
		endif
		
		rem unit timer trigger
		if Trigger( n ).active = 4
			
			rem check if time is up
			if Trigger( n ).time - timer() < 0
				
				rem execute script
				Unit.LastLoaded = Trigger( n ).UnitID
				RunScript( Trigger( n ).Script )
				
				rem if it's a one time only trigger, destroy
				if Trigger( n ).once = 1
					DestroyTrigger( n )
					
				rem reset time
				else
					Trigger( n ).time = timer() + Trigger( n ).resettime
					
				endif
				
			endif
		endif
		
   next n

endfunction
rem ---------------------------------------------------------------------------
rem Distortion
rem by TheComet
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type DistortionVT
   logging                                	as integer
	CurrentMax											as integer
endtype

type DistortionAT
   pos                                    	as vec3
   active                                 	as byte
   bend#                                  	as float
   bend_dec#                              	as float
   speed#                                 	as float
   sector                                 	as integer
   radius#                                	as float
endtype

rem ---------------------------------------------------------------------------
rem Initialize
rem ---------------------------------------------------------------------------

function InitDistortion()

   rem debug
   DebugOutput( 0 , "Initializing distortions" )

   rem ---------------------------------------------------------------------------
   rem Global Variables
   rem ---------------------------------------------------------------------------

   global Distortion                      	as DistortionVT

   rem ---------------------------------------------------------------------------
   rem Global Arrays
   rem ---------------------------------------------------------------------------

   global dim Distortion() 						as DistortionAT
   global dim vertexindex( 50 , 50 )				as dword

	rem initial values
	Distortion.CurrentMax = -1

   rem vertexdata index for distortion
   i = -1
   for y = 50 to 0 step -1
      for x = 0 to 50
         inc i
         vertexindex( x , y ) = i
      next x
   next y

   rem make a dummy object
   make object cube 1000 , 1
   hide object 1000

   rem make distortion object
   make object plain 1001 , 40 , 30 , 50 , 50
   position object 1001 , 0 , 0 , 25
   lock object on 1001
   set object light 1001 , 0
	set object filter 1001 , 0
	hide object 1001

   rem setup cameras for distortion
   make camera 1
   position camera 1 , 0 , 0 , 100000
   set camera to image 0 , 1001 , scw , sch
   set camera view 0 , 0 , scw , sch
   set current camera 0
	texture object 1001 , 1001

endfunction

function CreateDistortion( x# , y# , z# , bend# , bend_dec# , speed# , sector )

   rem locals
   local n as integer
	
	  rem log in console
   if Distortion.logging = 1 then AddTextToConsole( "CreateDistortion " + str$(n) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) + "," + str$(bend#) + "," + str$(bend_dec#) + "," + str$(speed#) + "," + str$(sector) , 0xFF00FFFF , 0 )

   rem search for free distortion
   for n = 0 to Distortion.CurrentMax
      if distortion( n ).active = 0 then exit
   next n

   rem no free distortion available, create
   if n = Distortion.CurrentMax + 1
      array insert at bottom Distortion()
		inc Distortion.CurrentMax
   endif

   rem set distortion parameters
   distortion( n ).active    = 2
   distortion( n ).pos.x#    = x#
   distortion( n ).pos.y#    = y#
   distortion( n ).pos.z#    = z#
   distortion( n ).bend#     = bend#
   distortion( n ).bend_dec# = bend_dec#
   distortion( n ).speed#    = speed#
   distortion( n ).sector    = sector
   distortion( n ).radius#   = 0.0

endfunction n

function DestroyDistortion( n )
	
	rem logging
	if distortion.logging = 1 then AddTextToConsole( "DestroyDistortion " + str$(n) , 0xFF00FFFF , 0 )

   rem make sure distortion is active
   if distortion( n ).active < 2
		if Distortion.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif

	rem destroy
	Distortion( n ).Active = 1

endfunction n

function ControlDistortion()

   rem locals
   local x as integer
   local y as integer
   local i as integer
   local n as integer
   local x1# as float
   local x2# as float
   local y1# as float
   local y2# as float
   local x1 as integer
   local x2 as integer
   local y1 as integer
   local y2 as integer

   rem lock vertexdata for editing
   lock vertexdata for limb 1001 , 0

      rem slowly reset all vertex positions
      for y = 0 to 50
         for x = 0 to 50
            x1# = get vertexdata position x(vertexindex(x,y))
            y1# = get vertexdata position y(vertexindex(x,y))
            x2# = (x*0.8) - 20.03125
            y2# = (y*0.6) - 14.96875
            if x1# <> x2# or y1# <> y2#
               set vertexdata position vertexindex( x , y ) , curvevalue( x2# , x1# , 1 / TBM.delta# ) , curvevalue( y2# , y1# , 1 / TBM.delta# ) , 0
               if abs( x1# -x2# ) < 0.01 and abs( y1# - y2#) < 0.001 then set vertexdata position vertexindex( x , y ) , x2# , y2# , 0
            endif
         next x
      next y

      rem loop through all active distortions
      for n = 0 to Distortion.CurrentMax
         if distortion( n ).active = 2

            rem convert real world coordinates to locked screen coordinates using a dummy object
            position object 1000 , distortion( n ).pos.x# , distortion( n ).pos.y# , distortion( n ).pos.z#
            x1 = object screen x( 1000 ) / (scw / 25)
            y1 = object screen y( 1000 ) / (sch / 25)

            rem invert y axis
            y1 = 50 - y1

            rem interpolate 4 steps
            for r = 1 to 4

               rem decrement bend factor
               dec distortion( n ).bend# , distortion( n ).bend_dec# * 0.25 * TBM.delta#
               if distortion( n ).bend# < 0
						distortion( n ).bend# = 0
						DestroyDistortion( n )
						exit
					endif

               rem increment radius
               inc distortion( n ).radius# , distortion( n ).speed# * 0.25 * TBM.delta#

               rem calculate 2d size and bend of 3d distortion
               x1# = sqrt( (camera position x() - distortion(n).pos.x#)^2 + (camera position y() - distortion(n).pos.y#)^2 + (camera position z() - distortion(n).pos.z#)^2 )
               x2# = distortion( n ).bend# / (x1# * 0.04)
               x1# = distortion( n ).radius# / (x1# * 0.04)

               rem calculate which verticies should distort
               for t = 0 to 360 step distortion( n ).sector
                  x2 = ( cos(t) * x1# ) + x1
                  y2 = ( sin(t) * x1# ) + y1

                  rem check if distortion is in range
                  if x2 > 0 and x2 < 50 and y2 > 0 and y2 < 50

                     rem distort
                     set vertexdata position vertexindex( x2 , y2 ) , curvevalue( (cos(t) * x2#) + ((x2 * 0.8) - 20) , get vertexdata position x( vertexindex( x2 , y2 ) ) , 10 ) , curvevalue((sin(t) * x2#) + ((y2 * 0.6) - 15) , get vertexdata position y( vertexindex( x2 , y2 ) ) , 10 / TBM.delta# ) , 0

                  endif
               next t
            next r
         endif
      next n

   rem unlock vertexdata
   unlock vertexdata

endfunction
rem --------------------------------------------------------------------------
rem menu
rem by TheComet
rem --------------------------------------------------------------------------

rem --------------------------------------------------------------------------
rem constants
rem --------------------------------------------------------------------------

#constant ButtonMax                 100
#constant SliderMax                 100

rem --------------------------------------------------------------------------
rem User Defined Types
rem --------------------------------------------------------------------------

type ButtonAT
   active as integer
   pos as vec2
   img as integer
endtype

type ButtonVT
   clicked as integer
endtype

type SliderAT
	Active as integer
	pos as vec2
	MaxValue as integer
	MinValue as integer
	CurrentValue as integer
	Info$ as string
endtype

type SliderVT
	drag as integer
	UpdateValue as integer
endtype

type MenuVT
	logging as integer
   CurrentMenu as integer
   ErrorMessage as integer
   SplashObj as word
   VolumeSlider as integer
endtype

rem --------------------------------------------------------------------------
rem initialize
rem --------------------------------------------------------------------------

function InitMenu()

   rem debug
   DebugOutput(0 , "Initializing menu, ButtonMax=" + str$(ButtonMax))

   rem --------------------------------------------------------------------------
   rem global variables
   rem --------------------------------------------------------------------------

   global Menu                      as MenuVT
	global Slider                    as SliderVT
   
   rem --------------------------------------------------------------------------
   rem global arrays
   rem --------------------------------------------------------------------------

   global dim Button( ButtonMax ) as ButtonAT
	global dim Slider( SliderMax ) as SliderAT
   
   rem --------------------------------------------------------------------------
   rem set values
   rem --------------------------------------------------------------------------

   Menu.CurrentMenu = -1   
	Slider.drag = -1
	Slider.UpdateValue = -1

endfunction

function CreateSplash()
	
	rem logging
	if Menu.logging = 1 then AddTextToConsole( "CreateSplash" , 0xFF00FFFF , 0 )

   rem if not created, create
   if Menu.SplashObj = 0
      Menu.SplashObj = find free object()
      make object plain Menu.SplashObj , 640 , 480
      lock object on Menu.SplashObj
      position object Menu.SplashObj , 0 , 0 , 400
      texture object Menu.SplashObj , SplashIMG
   endif
   
   rem show splash object
   show object Menu.SplashObj

endfunction

function DestroySplash()
	
	rem logging
	if Menu.logging = 1 then AddTextToConsole( "DestroySplash" , 0xFF00FFFF , 0 )

   rem destroy splash object
   hide object Menu.SplashObj

endfunction

function CreateMenu(n)

   rem logging
   if Menu.logging = 1 then AddTextToConsole("CreateMenu " + str$(n) , 0xFF00FFFF , 0)
   Menu.CurrentMenu = n

endfunction

function DestroyMenu()

   rem locals
   local n as integer
	
	rem logging
	if Menu.logging = 1 then AddTextToConsole( "DestroyMenu" , 0xFF00FFFF , 0 )
	
	rem destroy all sliders
	for n = 0 to SliderMax
		if Slider(n).Active > 1 then DestroySlider( n )
	next n
	
	rem destroy splash screen
   DestroySplash()
   
   rem current menu
   Menu.CurrentMenu = -1

endfunction

function ControlMenu()

   rem local variables
   local n as integer
   
endfunction

function CreateSlider(x , y , min_value , max_value , current_value , info$)
	
	rem local variables
	local n as integer
	
	rem logging
	if Menu.logging = 1 then AddTextToConsole( "CreateSlider " + str$(x) + "," + str$(y) + "," + str$(min_value) + "," + str$(max_value) + "," + str$(current_value) + "," + info$ , 0xFF00FFFF , 0 )
	
	rem find free slot
	for n = 0 to SliderMax
		if Slider( n ).active < 2 then exit
	next n
	
	rem no free slot found
	if n = SliderMax + 1
		if Menu.logging = 1 then AddTextToConsole( "No free slot!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem set values
	Slider( n ).active = 2
	Slider( n ).pos.x = x
	Slider( n ).pos.y = y
	Slider( n ).MaxValue = max_value
	Slider( n ).MinValue = min_value
	Slider( n ).CurrentValue = current_value
	Slider( n ).Info$ = info$
	
endfunction n

function DestroySlider( n )
	
	rem logging
	if Menu.logging = 1 then AddTextToConsole( "DestroySlider " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure it's active
	if Slider( n ).active < 2
		AddTextToConsole( "Slider not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy slider
	Slider( n ).active = 0
	
endfunction n

function ControlSlider()
	
	rem local variables
	local n as integer
	local x as integer
	local y as integer
	
	rem loop through all active sliders
	for n = 0 to SliderMax
		if Slider( n ).active = 2
			
			rem paste slider
			paste image SliderIMG , Slider( n ).pos.x , Slider( n ).pos.y , 1
			
			print "yeeah"
			
			rem if button is being dragged, calculate current value
			if Slider.drag = n
				x = mousex() - Slider( n ).pos.x - 25
				if x < 0 then x = 0
				if x > 150 then x = 150
				Slider( n ).Currentvalue = x * ( Slider( n ).MaxValue - Slider( n ).MinValue ) / 150.0 + Slider( n ).MinValue
			endif
			
			rem calculate slider button positions
			x = Slider( n ).pos.x + ( ( Slider( n ).CurrentValue - Slider( n ).MinValue ) * 150.0 / ( Slider( n ).MaxValue - Slider( n ).MinValue ) ) + 17
			y = Slider( n ).pos.y - 4
			paste image SliderButtonIMG , x , y , 1
			
			rem show current value
			a2text FontID , Slider( n ).pos.x + 200 , Slider( n ).pos.y , str$( Slider( n ).CurrentValue ) , 0xFFFFFFFF
			
			rem info
			a2text FontID , Slider( n ).pos.x , Slider( n ).pos.y - 20 , Slider( n ).Info$ , 0xF0B0B0B0
			
			rem drag button
			if mousex() > x and mousey() > y and mousex() < x + 16 and mousey() < y + 16
				paste image SliderButtonLightIMG , x , y , 1
				if Mouse.Click = 1 then Slider.drag = n
			endif
			
			rem let go
			if Mouse.click = 3 and Slider.drag = n
				Slider.drag = -1
				Slider.UpdateValue = n
			endif
		endif
	next n
	
endfunction
rem ---------------------------------------------------------------------------
rem Mouse control - Because the stupid DBP mousemove() commands are bugged
rem by TheComet
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type MouseVT
   oldclick as integer
   currentclick as integer
   click as integer
   x as integer
   y as integer
   z as integer
   oldx as integer
   oldy as integer
   oldz as integer
   Movex as integer
   Movey as integer
   Movez as integer
	Click3D as vec3
	StorePos as vec2
	Click3DFound as integer
endtype

rem ---------------------------------------------------------------------------
rem initialize
rem ---------------------------------------------------------------------------

function InitMouse()

   rem debug
   DebugOutput(0 , "Initialising mouse")

   rem ---------------------------------------------------------------------------
   rem Global variables
   rem ---------------------------------------------------------------------------

   global Mouse                  as MouseVT

endfunction

function ControlMouse()

   rem process mouse clicks
   Mouse.oldclick=Mouse.currentclick
   Mouse.currentclick=mouseclick()
   if Mouse.oldclick=0 and Mouse.currentclick=0 then Mouse.click=0
   if Mouse.oldclick=0 and Mouse.currentclick=1 then Mouse.click=1
   if Mouse.oldclick=1 and Mouse.currentclick=1 then Mouse.click=2
   if Mouse.oldclick=1 and Mouse.currentclick=0 then Mouse.click=3
   if Mouse.oldclick=0 and Mouse.currentclick=2 then Mouse.click=4
   if Mouse.oldclick=2 and Mouse.currentclick=2 then Mouse.click=5
   if Mouse.oldclick=2 and Mouse.currentclick=0 then Mouse.click=6
   if Mouse.oldclick=0 and Mouse.currentclick=4 then Mouse.click=7
   if Mouse.oldclick=4 and Mouse.currentclick=4 then Mouse.click=8
   if Mouse.oldclick=4 and Mouse.currentclick=0 then Mouse.click=9

   rem process mouse x
   Mouse.oldx = Mouse.x
   Mouse.x = mousex()
   Mouse.Movex = Mouse.x - Mouse.oldx

   rem process mouse y
   Mouse.oldy = Mouse.y
   Mouse.y = mousey()
   Mouse.Movey = Mouse.y - Mouse.oldy

   rem process mouse z
   Mouse.oldz = Mouse.z
   Mouse.z = mousez()
   Mouse.Movez = Mouse.z - Mouse.oldz
	
	rem 3D clicks
	if Mouse.Click > 0
		if pick object( Mouse.x , Mouse.y , 1 , World.PickSearchObj )
			Mouse.Click3DFound = 1
			Mouse.Click3D.x# = get pick vector x() + camera position x()
			Mouse.Click3D.y# = get pick vector y() + camera position y()
			Mouse.Click3D.z# = get pick vector z() + camera position z()
			rem if Mouse.click = 4 then CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , 0xFF00FF00 , 320 )
		else
			Mouse.Click3DFound = 0
		endif
	endif
	
	rem if middle mouse is clicked, store positions and hide
	if Mouse.Click = 7
		Mouse.StorePos.x = Mouse.x
		Mouse.StorePos.y = Mouse.y
		hide mouse
	endif
	
	rem if middle mouse is released, restore mouse and show
	if Mouse.Click = 9
		position mouse Mouse.StorePos.x , Mouse.StorePos.y
		show mouse
	endif

endfunction
rem ---------------------------------------------------------------------------
rem Messages
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type MessageVT
	logging 												as integer
	CurrentMax											as integer
endtype

type MessageAT
   active 												as integer
   pos 													as vec2
   life 													as integer
   color 												as dword
   text$ 												as string
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitMessage()

   rem debug
   DebugOutput( 0 , "Initialising messages" )
	
	rem ---------------------------------------------------------------------------
	rem global variables
	rem ---------------------------------------------------------------------------
	
	global Message 									as MessageVT

   rem ---------------------------------------------------------------------------
   rem global arrays
   rem ---------------------------------------------------------------------------

   global dim Message() 							as MessageAT
	
	rem initial values
	Message.CurrentMax = -1
   
endfunction

function CreateMessage( x , y , text$ , life , color )

   rem locals
   local n as integer
	
	rem logging
	if Message.logging = 1 then AddTextToConsole( "CreateMessage " + str$(x) + "," + str$(y) + "," + chr$(34) + text$ + chr$(34) + "," + str$(life) + "," + str$(color) , 0xFF00FFFF , 0 )
   
   rem find free slot for message
   for n = 0 to Message.CurrentMax
      if Message( n ).active = 0 then exit
   next n
   
   rem no free slot, create
   if n = Message.CurrentMax + 1
		array insert at bottom Message()
		inc Message.CurrentMax
	endif
   
   rem create message
   Message( n ).text$ = text$
   
   rem set parameters
   Message( n ).active = 2
   Message( n ).pos.x = x
   Message( n ).pos.y = y
   Message( n ).life = timer() + (life * 16.6666)
   Message( n ).color = color
	
	rem infinite time
	if life = 0 then Message( n ).life = 0
   
endfunction n

function DestroyMessage( n )
	
	rem logging
	if Message.logging = 1 then AddTextToConsole( "DestroyMessage " + str$(n) , 0xFF00FFFF , 0 )

   rem make sure message is active
   if Message( n ).active < 2
		if Message.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
   
	rem destroy message
	Message( n ).Active = 1
   
endfunction n

function ControlMessage()

   rem locals
   local n as integer
   
   rem loop through all active messages
   for n = 0 to Message.CurrentMax
      if Message( n ).active = 2
      
         rem print message to screen
         ink Message( n ).color
         text Message( n ).pos.x , Message( n ).pos.y , Message( n ).text$
         
         rem decrement life of message
			if Message( n ).life <> 0
				if Message( n ).life - timer() < 0 then DestroyMessage( n )
			endif
         
      endif
   next n
   
endfunction
rem ---------------------------------------------------------------------------
rem Camera control code
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------



rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type CameraVT
	logging                          as integer
	Mode                             as integer
	Height#                          as float
	Pos                              as vec3
	MaxPos                           as vec3
	MinPos                           as vec3
	angle                            as vec3
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitCamera()
	
	rem debug
	DebugOutput( 0 , "Initialising Camera" )
	
	rem ---------------------------------------------------------------------------
	rem Global Variables
	rem ---------------------------------------------------------------------------
	
	global Camera                    as CameraVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------
	
	rem ---------------------------------------------------------------------------
	rem Initial values
	rem ---------------------------------------------------------------------------
	
	Camera.Mode = 1
	Camera.angle.x# = 60
	Camera.Height# = 18
	
endfunction

function SetCameraMode( n )
	if Camera.logging = 1 then AddTextToConsole( "SetCameraMode " + str$(n) , 0xFF00FFFF , 0 )
	Camera.Mode = n
endfunction

function ControlCamera()
	
	rem normal mode
	if Camera.Mode = 1
		
		rem player is not box selecting
		if UnitBoxSelect.Active = 0
			
			rem scroll around map with mouse
			if Mouse.click = 0
				if mousex() < 20 then dec Camera.Pos.x# , (20 - mousex()) * 0.16 * TBM.delta#
				if mousex() > scw - 20 then dec Camera.Pos.x# , (scw - 20 - mousex()) * 0.16 * TBM.delta#
				if mousey() < 20 then inc Camera.Pos.z# , (20 - mousey()) * 0.16 * TBM.delta#
				if mousey() > sch - 20 then inc camera.Pos.z# , (sch - 20 - mousey()) * 0.16 * TBM.delta#
			endif
			
			rem scroll around map with keys
			if upkey() then inc Camera.Pos.z# , 1.5 * TBM.delta#
			if downkey() then dec Camera.Pos.z# , 1.5 * TBM.delta#
			if leftkey() then dec Camera.Pos.x# , 1.5 * TBM.delta#
			if rightkey() then inc Camera.Pos.x# , 1.5 * TBM.delta#
			
			rem middle mouse button
			if Mouse.click = 8 or keystate(56)
				inc Camera.Pos.x# , Mouse.movex * 0.03
				dec Camera.Pos.z# , Mouse.Movey * 0.03
			endif
			
			rem camera limits
			if Camera.pos.x# > Camera.MaxPos.x# then Camera.Pos.x# = Camera.MaxPos.x#
			if Camera.Pos.x# < Camera.MinPos.x# then Camera.Pos.x# = Camera.MinPos.x#
			if Camera.Pos.z# > Camera.MaxPos.z# then Camera.Pos.z# = Camera.MaxPos.z#
			if Camera.Pos.z# < Camera.MinPos.z# then Camera.Pos.z# = Camera.MinPos.z#
			
			rem height
			if keystate(24) then dec Camera.Height# , 3 * TBM.delta#
			if keystate(25) then inc Camera.Height# , 3 * TBM.delta#
			if Camera.Height# < 1 then Camera.Height# = 1
			if Camera.Height# > 18 then Camera.Height# = 18
			Camera.angle.x# = curveangle( 3 * Camera.Height# , Camera.angle.x# , 10.0 / TBM.delta# )
			
			rem find camera height
			if SC_RayCastGroup( 1 , Camera.Pos.x# , 200 , Camera.Pos.z# + 8 , Camera.Pos.x# , -200 , Camera.Pos.z# + 8 , 0 )
				Camera.Pos.y# = curvevalue( SC_GetStaticCollisionY() + Camera.Height# , Camera.Pos.y# , 5 / TBM.delta# )
			endif
			
			rem update camera
			position camera Camera.Pos.x# , Camera.Pos.y# , Camera.Pos.z#
			rotate camera Camera.angle.x# , Camera.angle.y# , Camera.angle.z#
		
		endif
		
	endif
	
	rem light
	set vector4 2 , camera position x() + 4 , camera position y() , camera position z() + 4 , 0
	set effect constant vector ParallaxMappingFX , "LightPosition" , 2
	
endfunction
rem ---------------------------------------------------------------------------
rem World - Handles everything to do with world loading / control
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem constants
rem ---------------------------------------------------------------------------

#constant WorldMaxObj               50

rem object types
#constant WORLD_TERRAIN             1
#constant WORLD_SCENERY             2

rem collision types
#constant COL_TERRAIN               1
#constant COL_PATHFINDER            2
#constant COL_UNIT                  3

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type PathfinderVT
	ResolutionX                      as integer
	ResolutionY                      as integer
	StartX#                          as float
	StartY#                          as float
	EndX#                            as float
	EndY#                            as float
	Threshold                        as integer
	ID                               as integer
	ShowPathmap                      as integer
	Obj                              as word
endtype

type FogOfWarVT
	StartX#                          as float
	StartY#                          as float
	EndX#                            as float
	EndY#                            as float
	ResolutionX                      as float
	ResolutionY                      as float
	Obj                              as word
	CurrentVertex                    as integer
	FadeSpeed                        as integer
endtype

type WorldVT
	logging                          as integer
	SlotPointer                      as integer
	PickSearchObj                    as integer
	PathFinder                       as PathfinderVT
	FogOfWar                         as FogOfWarVT
endtype

type WorldAT
	Obj                              as word
	Typ                              as integer
endtype

type FogOfWarVertexAAT
	VertexIndex                      as integer
endtype

type FogOfWarVertexBrushAAT
	Color                            as dword
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitWorld()
	
	rem local variables
	local x as integer
	local y as integer
	local n as integer
	local dist as dword
	
	rem debug
	DebugOutput( 0 , "Initialising World" )
	
	rem ---------------------------------------------------------------------------
	rem global variables
	rem ---------------------------------------------------------------------------
	
	global World                     as WorldVT
	
	rem ---------------------------------------------------------------------------
	rem global arrays
	rem ---------------------------------------------------------------------------
	
	global dim World( WorldMaxObj )  as WorldAT
	global dim FogOFWarVertexBrush( 20 , 20 ) as FogOfWarVertexBrushAAT
	
	rem ---------------------------------------------------------------------------
	rem initial values
	rem ---------------------------------------------------------------------------
	
	World.SlotPointer = -1
	World.Pathfinder.ID = -1
	
	rem radius 10 brush
	for x = 0 to 20
		for y = 0 to 20
			dist = (x-10)^2 + (y-10)^2
			if dist < 64
				FogOfWarVertexBrush( x , y ).Color = 0x00000000
			else
				n = dist * 3 - 192
				if n > 255 then n = 255
				FogOfWarVertexBrush( x , y ).Color = (n << 56)
			endif
		next y
	next x
	
endfunction

function DestroyWorld()
	
	rem local variables
	local n as integer
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "DestroyWorld" , 0xFF00FFFF , 0 )
	
	rem delete all objects used
	for n = 0 to World.SlotPointer
		if World( n ).Obj > 0
			if object exist( World( n ).Obj )
				delete object World( n ).Obj
				if World( n ).Typ = WORLD_SCENERY then SC_RemoveObject World( n ).Obj
				World( n ).Obj = 0
			endif
		endif
	next n

	rem reset slot pointer
	World.SlotPointer = -1
	
	rem delete the pathfinder
	if World.PathFinder.ID > -1
		iaa_delete pathfinder World.PathFinder.ID
		World.PathFinder.ID = -1
		SC_RemoveObject World.PathFinder.Obj
		delete object World.PathFinder.Obj
	endif
	
	rem destroy fog of war
	WorldDestroyFogOfWar()

endfunction

function WorldAddSceneryObject( FileName$ )
	
	rem local variables
	local n as integer
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldAddSceneryObject " + Filename$ , 0xFF00FFFF , 0 )
	
	rem increment slot pointer
	inc World.SlotPointer
	
	rem no free slot
	if World.SlotPointer = WorldMaxObj + 1
		if World.logging = 1 then AddTextToConsole( "No free slot!" , 0xFFFF0000 , 3 )
		dec World.SlotPointer
		exitfunction -1
	endif
	
	rem file doesn't exist
	if file exist( FileName$ ) = 0
		if World.logging = 1 then AddTextToConsole( "File " + chr$(34) + FileName$ + chr$(34) + " does not exist!" , 0xFFFF0000 , 3 )
		dec World.SlotPointer
		exitfunction -1
	endif
	
	rem load scenery object
	World( World.SlotPointer ).Obj = find free object()
	load object FileName$ , World( World.SlotPointer ).Obj
	
	rem type
	World( World.SlotPointer ).Typ = WORLD_SCENERY
	
endfunction 0

function WorldAddTerrainObject( FileName$ )
	
	rem local variables
	local n as integer
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldAddTerrainObject " + Filename$ , 0xFF00FFFF , 0 )
	
	rem increment slot pointer
	inc World.SlotPointer
	
	rem no free slot
	if World.SlotPointer = WorldMaxObj + 1
		if World.logging = 1 then AddTextToConsole( "No free slot!" , 0xFFFF0000 , 3 )
		dec World.SlotPointer
		exitfunction -1
	endif
	
	rem file doesn't exist
	if file exist( FileName$ ) = 0
		if World.logging = 1 then AddTextToConsole( "File " + chr$(34) + FileName$ + chr$(34) + " does not exist!" , 0xFFFF0000 , 3 )
		dec World.SlotPointer
		exitfunction -1
	endif
	
	rem load terrain
	World( World.SlotPointer ).Obj = find free object()
	load object FileName$ , World( World.SlotPointer ).Obj
	set object cull World( World.SlotPointer ).Obj , 1
	SC_SetupComplexObject World( World.SlotPointer ).Obj , COL_TERRAIN , 2
	
	rem set type
	World( World.SlotPointer ).Typ = WORLD_TERRAIN
	
	rem update pick object object range
	World.PickSearchObj = World( World.SlotPointer ).Obj
	
endfunction 0

function WorldCreateFogOfWar( StartX# , StartY# , EndX# , EndY# , ResolutionX , ResolutionY )
	
	rem local variables
	local x as integer
	local y as integer
	local i as integer
	local SizeX# as float
	local SizeY# as float
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldCreateFogOfWar " + str$(StartX#) + "," + str$(StartY#) + "," + str$(EndX#) + "," + str$(EndY#) + "," + str$(ResolutionX) + "," + str$(ResolutionY) , 0xFF00FFFF , 0 )
	
	rem make sure it hasn't already been created
	if World.FogOfWar.Obj > 0
		if World.logging = 1 then AddTextToConsole( "Already active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem calculate size
	SizeX# = EndX# - StartX#
	SizeY# = EndY# - StartY#
	
	rem create
	rem World.FogOfWar.Obj = GenerateFogOfWar( StartX# , StartY# , EndX# , EndY# , ResolutionX , ResolutionY )
	World.FogOfWar.Obj = find free object()
	make object plain World.FogOfWar.Obj , EndX# - StartX# , EndY# - StartY# , ResolutionX , ResolutionY
	make mesh from object 1 , World.FogOfWar.Obj
	delete object World.FogOfWar.Obj
	make object World.FogOfWar.Obj , 1 , 0
	delete mesh 1
	set object transparency World.FogOfWar.Obj , 2
	disable object zdepth World.FogOfWar.Obj
	set object light World.FogOfWar.Obj , 0
	rem set object wireframe World.FogOfWar.Obj , 1
	WrapObjectOnTerrain( World.FogOfWar.Obj )
	
	rem set values
	World.FogOfWar.StartX# = StartX#
	World.FogOfWar.StartY# = StartY#
	World.FogOfWar.EndX# = EndX#
	World.FogOfWar.EndY# = EndY#
	World.FogOfWar.ResolutionX = ResolutionX
	World.FogOfWar.ResolutionY = ResolutionY
	World.FogOfWar.CurrentVertex = 0
	World.FogOfWar.FadeSpeed = 25
	
	rem create vertex array
	global dim FogOfWarVertex( ResolutionX , ResolutionY ) as FogOfWarVertexAAT
	
	rem fill with data
	i = 0
	for y = 1 to ResolutionY
		for x = 1 to ResolutionX
			FogOfWarVertex( x , y ).VertexIndex = i
			inc i , 6
		next x
	next y
	
	SetObjectDiffuse( World.FogOfWar.Obj , 0xFFFF0000 )

endfunction n

function WorldDestroyFogOfWar()
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldDestroyFogOfWar" , 0xFF00FFFF , 0 )
	
	rem make sure it's active
	if World.FogOfWar.Obj = 0
		if World.logging = 1 then AddTextToConsole( "World not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy
	delete object World.FogOfWar.Obj
	World.FogOfWar.Obj = 0
	undim FogOfWarVertex()
	
endfunction n

function WorldCreatePathfinder( FileName$ , StartX# , StartY# , EndX# , EndY# , ResolutionX , ResolutionY , HeightThreshold )
	
	rem local variables
	local x as integer
	local y as integer
	local x# as float
	local z# as float
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldCreatePathfinder" , 0xFF00FFFF , 0 )
	
	rem file doesn't exist
	if file exist( FileName$ ) = 0
		if World.logging = 1 then AddTextToConsole( "File does not exist!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem make sure path hasn't already been loaded
	if World.Pathfinder.ID > -1
		if World.logging = 1 then AddTextToConsole( "Pathfinder has already been set up!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem load object
	World.PathFinder.Obj = find free object()
	load object FileName$ , World.PathFinder.Obj
	SC_SetupComplexObject World.PathFinder.Obj , COL_PATHFINDER , 2
	texture object World.PathFinder.Obj , IMGBlack
	ghost object on World.PathFinder.Obj
	disable object zwrite World.PathFinder.Obj
	
	rem create the pathfinder
	World.PathFinder.ResolutionX = ResolutionX
	World.PathFinder.ResolutionY = ResolutionY
	World.PathFinder.StartX# = StartX#
	World.PathFinder.EndX# = EndX#
	World.PathFinder.StartY# = StartY#
	World.PathFinder.EndY# = EndY#
	World.PathFinder.Threshold = HeightThreshold
	World.PathFinder.ID = iaa_create pathfinder( ResolutionX + 1 , ResolutionY + 1 , 1 , 1 )

	rem create pathmap
	for x = 0 to ResolutionX
		for y = 0 to ResolutionY
			
			rem calculate positions
			x# = StartX# + (((EndX# - StartX#) * x) / ResolutionX)
			z# = StartY# + (((EndY# - StartY#) * y) / ResolutionY)
			
			rem check if threshold is met
			if SC_RayCast( World.PathFinder.Obj , x# , 200 , z# , x# , -200 , z# , 0 )
				if SC_GetStaticCollisionY() > HeightThreshold
					iaa_set pathmap value World.PathFinder.ID , x , y , 1
				else
					iaa_set pathmap value World.PathFinder.ID , x , y , 0
				endif
			else
				iaa_set pathmap value World.PathFinder.ID , x , y , 0
			endif
		next y
	next x
	
endfunction 0

function WorldShowPathmap()
	
	rem local variables
	local x as integer
	local y as integer
	local n as integer
	local Obj as word
	local mesh as word
	local x# as float
	local y# as float
	local z# as float
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldShowPathmap" , 0xFF00FFFF , 0 )
	
	rem check if pathfinder is active
	if World.PathFinder.ID = -1
		if World.logging = 1 then AddTextToConsole( "Pathfinder not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if pathmap is already showing
	if World.PathFinder.ShowPathmap = 1
		if World.logging = 1 then AddTextToConsole( "Pathmap already active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem visualise pathmap
	Obj = find free object()
	make object cube Obj , 0.6
	mesh = find free mesh()
	make mesh from object mesh , Obj
	delete object Obj
	make object plain Obj , 0 , 0
	n = 0
	for x = 0 to World.PathFinder.ResolutionX
		for y = 0 to World.PathFinder.ResolutionY
			
			rem get positions
			x# = World.PathFinder.StartX# + (((World.PathFinder.EndX# - World.PathFinder.StartX#) * x) / World.PathFinder.ResolutionX)
			z# = World.PathFinder.StartY# + (((World.PathFinder.EndY# - World.PathFinder.StartY#) * y) / World.PathFinder.ResolutionY)
			if SC_RayCastGroup( 1 , x# , 200 , z# , x# , -200 , z# , 0 ) and iaa_get pathmap value( World.PathFinder.ID , x , y )
				y# = SC_GetStaticCollisionY()
				inc n
				add limb Obj , n , mesh
				offset limb Obj , n , x# , y# , z#
				color limb Obj , n , 0xFFFF0000
			endif
			
		next y
	next x
	
	rem clean up
	delete mesh mesh
	
	rem store object in variable
	World.PathFinder.ShowPathmap = Obj
	
endfunction 0

function WorldHidePathmap()
	
	rem logging
	if World.logging = 1 then AddTextToConsole( "WorldHidePathmap" , 0xFF00FFFF , 0 )
	
	rem check if pathfinder is active
	if World.PathFinder.ID = -1
		if World.logging = 1 then AddTextToConsole( "Pathfinder not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if pathmap is showing
	if World.PathFinder.ShowPathmap = -1
		if World.logging = 1 then AddTextToConsole( "Pathmap already hiding!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem delete the object
	if object exist( World.PathFinder.ShowPathmap ) then delete object World.PathFinder.ShowPathmap
	
endfunction 0

function ControlWorld()
	
	rem local variables
	local n as dword
	local i as dword
	local x as integer
	local y as integer
	local sx as integer
	local sy as integer
	local x# as float
	local y# as float
	local z# as float
	local dist# as float
	
	rem control fog of war
	if World.FogOfWar.Obj > 0
		
		rem edit vertex data
		lock vertexdata for limb World.FogOfWar.Obj , 0
		
			rem 500 vertices every loop
			for i = 1 to 500
				
				rem select next vertex
				inc World.FogOfWar.CurrentVertex
				if World.FogOfWar.CurrentVertex > get vertexdata vertex count() - 1
					World.FogOfWar.CurrentVertex = 0
				endif
				
				rem get positions
				x# = get vertexdata position x( World.FogOfWar.CurrentVertex )
				y# = get vertexdata position y( World.FogOfWar.CurrentVertex )
				z# = get vertexdata position z( World.FogOfWar.CurrentVertex )
				
				rem slowly reset colour
				n = get vertexdata diffuse( World.FogOfWar.CurrentVertex )
				n = (n >> 56)
				if n < 180 then inc n , World.FogOfWar.FadeSpeed
				if n > 180 and n < 250 then n = 180
				n = (n << 56)
				set vertexdata diffuse World.FogOfWar.CurrentVertex , n
				
			next i
			
			rem find units that are controlled by player
			for n = 0 to Unit.CurrentMax
				if Unit( n ).Active > 1 and Unit( n ).Control = UNITCONTROL_PLAYER
					
					rem calculate unit grid coordinates
					sx = ((Unit( n ).pos.x# - World.FogOfWar.StartX#) * World.FogOfWar.ResolutionX) / (World.FogOfWar.EndX# - World.FogOfWar.StartX#)
					sy = ((Unit( n ).pos.z# - World.FogOfWar.Starty#) * World.FogOfWar.ResolutionY) / (World.FogOfWar.EndY# - World.FogOfWar.StartY#)
					dec sx , 10
					dec sy , 10
					
					rem copy brush array to vertex diffuse data
					for x = 0 to 20
						for y = 0 to 20
							if sx + x > 0 and sx + x < World.FogOfWar.ResolutionX
								if sy + y > 0 and sy + y < World.FogOfWar.ResolutionY
									if get vertexdata diffuse( FogOfWarVertex( sx + x , sy + y ).VertexIndex ) > FogOfWarVertexBrush( x , y ).Color
										set vertexdata diffuse FogOfWarVertex( sx + x , sy + y ).VertexIndex , FogOfWarVertexBrush( x , y ).Color
									endif
								endif
							endif
						next y
					next x
					
				endif
			next n
			
		unlock vertexdata
		
	endif
	
endfunction

function WrapObjectOnTerrain( Obj )
	
	rem local variables
	local i as integer
	local x# as float
	local y# as float
	local z# as float
	
	rem loop through each vertex
	lock vertexdata for limb Obj , 0
		for i = 0 to get vertexdata vertex count() - 1
			
			rem get positions
			x# = get vertexdata position x(i)
			y# = get vertexdata position y(i)
			z# = get vertexdata position z(i)
			
			rem raycast
			if SC_RayCastGroup( COL_TERRAIN , x# , 200 , z# , x# , -200 , z# , 0 )
				y# = SC_GetStaticCollisionY()
				set vertexdata position i , x# , y# , z#
			endif
			
		next i
	unlock vertexdata
	
endfunction

function GenerateFogOfWar( StartX# , StartY# , EndX# , EndY# , ResolutionX , ResolutionY )
	
	rem local variables
	local mem as word
	local mesh as word
	local Obj as word
	local FVF as dword
	local vertSize as dword
	local vertCount as dword
	local pos as dword
	local x as integer
	local y as integer
	local SizeX# as float
	local SizeY# as float
	local Index as dword
	local Vertex as dword
	
	rem calculate size of map
	SizeX# = EndX# - StartX#
	SizeY# = EndY# - StartY#
	
	rem calculate header data
	FVF = 338
	vertSize = 36
	vertCount = ResolutionX * ResolutionY * 6
	
	rem create memblock
	mem = find free memblock()
	make memblock mem , vertCount * vertSize + 12
	
	rem write header
	write memblock dword mem , 0 , 338
	write memblock dword mem , 4 , vertSize
	write memblock dword mem , 8 , vertCount
	
	rem write face data (total of 6 vertices)
	pos = 12
	for x = 1 to ResolutionX
		for y = 1 to ResolutionY
			 
			rem vertex 1
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+1))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+0))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0xFF000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize

			rem vertex 2
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+0))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+0))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0xFF000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize

			rem vertex 3
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+0))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+1))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0x00000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize

			rem vertex 4
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+1))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+0))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0xFF000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize

			rem vertex 5
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+0))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+1))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0xFF000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize

			rem vertex 6
			write memblock float mem , pos + 0 , StartX# + ((SizeX#*(x+1))/ResolutionX)
			write memblock float mem , pos + 4 , 0.0
			write memblock float mem , pos + 8 , StartY# + ((SizeY#*(y+1))/ResolutionY)
			write memblock float mem , pos + 12, 0.0
			write memblock float mem , pos + 16, 1.0
			write memblock float mem , pos + 20, 0.0
			write memblock dword mem , pos + 24, 0x00000000
			write memblock float mem , pos + 28, 0.0
			write memblock float mem , pos + 32, 0.0
			inc pos , vertSize
			
		next y
	next x
	
	rem convert to object
	mesh = find free mesh()
	Obj = find free object()
	make mesh from memblock mesh , mem
	make object Obj , mesh , 0
	
	rem clean up
	delete mesh mesh
	delete memblock mem
	
	remstart weld vertices together
	lock vertexdata for limb obj , 0
		Index = 0
		Vertex = 0
		for y = 1 to ResolutionY
			for x = 1 to ResolutionX
				set indexdata Index + 1 , Vertex + 0
				set indexdata Index + 0 , Vertex + 1
				set indexdata Index + ((ResolutionX+1)*y) , Vertex + 2
				set indexdata Index + 1 , Vertex + 3
				set indexdata Index + ((ResolutionX+1)*y) , Vertex + 4
				set indexdata Index + ((ResolutionX+1)*y) + 1 , Vertex + 5
				inc Index
				inc Vertex , 6
			next x
		next y
	unlock vertexdata
	remend
	
endfunction Obj
rem ---------------------------------------------------------------------------
rem Unit box select - Controls selection of units by dragging a box
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant UNITBOXSELECT_ENABLE      1
#constant UNITBOXSELECT_DISABLE     2

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type UnitBoxSelectVT
	logging                          as integer
	state                            as integer
	Active                           as integer
	sx                               as integer
	sy                               as integer
	ex                               as integer
	ey                               as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitUnitBoxSelect()

	rem debug
	DebugOutput( 0 , "Initialising UnitBoxSelect" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global UnitBoxSelect             as UnitBoxSelectVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------

endfunction

function UnitBoxSelectEnable()
	if UnitBoxSelect.logging = 1 then AddTextToConsole( "UnitBoxSelectEnable" , 0xFF00FFFF ,0  )
	UnitBoxSelect.state = UNITBOXSELECT_ENABLE
endfunction

function UnitBoxSelectDisable()
	if UnitBoxSelect.logging = 1 then AddTextToConsole( "UnitBoxSelectDisable" , 0xFF00FFFF , 0 )
	UnitBoxSelect.state = UNITBOXSELECT_DISABLE
endfunction

function ControlUnitBoxSelect()
	
	rem check if enabled
	if UnitBoxSelect.state = UNITBOXSELECT_ENABLE
		
		rem start drawing the box
		if Mouse.click = 1 and GUI.MouseClickInvalid = 0
			UnitBoxSelect.Active = 1
			UnitBoxSelect.sx = Mouse.x
			UnitBoxSelect.sy = Mouse.y
			UnitBoxSelect.ex = Mouse.x
			UnitBoxSelect.ey = Mouse.y
		endif
		
		rem change size of box
		if Mouse.click = 2
			UnitBoxSelect.ex = Mouse.x
			UnitBoxSelect.ey = Mouse.y
		endif
		
		rem finish drawing the box
		if Mouse.click = 3 and UnitBoxSelect.Active = 1
			UnitBoxSelect.ex = Mouse.x
			UnitBoxSelect.ey = Mouse.y
			UnitBoxSelect.Active = 2          : rem this flag is detected in ControlUnit()
		endif
		
		rem disable drag box
		if Mouse.click = 0 then UnitBoxSelect.Active = 0
		
		rem draw box to screen
		if UnitBoxSelect.Active > 0
			a2fillbox UnitBoxSelect.sx , UnitBoxSelect.sy , UnitBoxSelect.ex , UnitBoxSelect.ey , 0x3000FF00
			a2box UnitBoxSelect.sx , UnitBoxSelect.sy , UnitBoxSelect.ex , UnitBoxSelect.ey , 0xFF00FF00
		endif
		
	endif

endfunction

rem -----------------------------------------------------------
rem Animation - Controls animations of objects
rem -----------------------------------------------------------

rem -----------------------------------------------------------
rem Constants
rem -----------------------------------------------------------

rem -----------------------------------------------------------
rem User Defined Types
rem -----------------------------------------------------------

type AnimationVT
   logging 												as integer
	CurrentMax 											as integer
endtype

type AnimationAT
   Active 												as integer
   CurrentFrame# 										as float
   StartFrame# 										as float
   EndFrame# 											as float
   Speed# 												as float
   Obj 													as word
endtype

rem -----------------------------------------------------------
rem Initialise
rem -----------------------------------------------------------

function InitAnimation()

   rem debug
   DebugOutput(0 , "Initialising Animation" )
   
   rem -----------------------------------------------------------
   rem global variables
   rem -----------------------------------------------------------

   global Animation 									as AnimationVT
   
   rem -----------------------------------------------------------
   rem global arrays
   rem -----------------------------------------------------------

   global dim Animation() 							as AnimationAT
	
	rem initial values
	Animation.CurrentMax = -1
   
endfunction

function PlayObject( Obj , StartFrame# , EndFrame# , Speed# )
   
   rem logging
   if Animation.logging = 1 then AddTextToConsole( "PlayObject " + str$( Obj ) + "," + str$( StartFrame# ) + "," + str$( EndFrame# ) + "," + str$( Speed# ) , 0xFFFFFFFF , 0 )

	rem invalid speed
	if Speed# = 0.0 then exitfunction
	
	rem local variables
   local n as integer

   rem find free slot
   for n = 0 to Animation.CurrentMax
      if Animation( n ).Active < 2 then exit
   next n
   
   rem no free slot found, create
   if n = Animation.CurrentMax + 1
      array insert at bottom Animation()
		inc Animation.CurrentMax
   endif
   
   rem set frame
   set object frame Obj , StartFrame#
   
   rem set values
   Animation( n ).Active        = 2
   Animation( n ).Obj           = Obj
   Animation( n ).StartFrame#   = StartFrame#
   Animation( n ).EndFrame#     = EndFrame#
   if Speed# > 0 then Animation( n ).CurrentFrame# = StartFrame#
	if Speed# < 0 then Animation( n ).CurrentFrame# = EndFrame#
   Animation( n ).Speed#        = Speed#
   
endfunction

function LoopObject( Obj , StartFrame# , EndFrame# , Speed# )
   
   rem logging
   if Animation.logging = 1 then AddTextToConsole( "LoopObject " + str$( Obj ) + "," + str$( StartFrame# ) + "," + str$( EndFrame# ) + "," + str$( Speed# ) , 0xFFFFFFFF , 0 )

	rem invalid speed
	if Speed# = 0.0 then exitfunction
	
	rem local variables
   local n as integer

   rem find free slot
   for n = 0 to AnimationMax
      if Animation(n).Active < 2 then exit
   next n
   
   rem no free slot found, create
   if n = Animation.CurrentMax + 1
      array insert at bottom Animation()
		inc Animation.CurrentMax
   endif
   
   rem set frame
   set object frame Obj , StartFrame#
   
   rem set values
   Animation( n ).Active        = 3
   Animation( n ).Obj           = Obj
   Animation( n ).StartFrame#   = StartFrame#
   Animation( n ).EndFrame#     = EndFrame#
   if Speed# > 0 then Animation( n ).CurrentFrame# = StartFrame#
	if Speed# < 0 then Animation( n ).CurrentFrame# = EndFrame#
   Animation( n ).Speed#        = Speed#
   
endfunction

function StopObject( Obj )

   rem local variables
   local n as integer

   rem logging
   if Animation.logging = 1 then AddTextToConsole( "StopObject " + str$( Obj ) , 0xFFFFFFFF , 0 )
   
   rem find animation index of object
   for n = 0 to Animation.CurrentMax
      if Animation( n ).Obj = Obj then exit
   next n
   
   rem not found
   if n = Animation.CurrentMax + 1
      if Animation.logging = 1 then AddTextToConsole( "Object not Active!" , 0xFFFF0000 , 3 )
      exitfunction
   endif

   rem make sure animation is Active
   if Animation( n ).Active < 2
      if Animation.logging = 1 then AddTextToConsole( "Animation not Active!" , 0xFFFF0000 , 3 )
      exitfunction
   endif
   
   rem set frame
   set object frame Animation( n ).Obj , Animation( n ).CurrentFrame#
   
   rem stop object
   Animation( n ).Active  = 0
   Animation( n ).Obj     = 0
   
endfunction

function ObjectPlaying( Obj )

   rem local variables
   local n as integer

   rem find animation index of object
   for n = 0 to Animation.CurrentMax
      if Animation( n ).Obj = Obj then exit
   next n
   
   rem not found
   if n = Animation.CurrentMax + 1
      if Animation.logging = 1 then AddTextToConsole( "Object not playing!" , 0xFFFF0000 , 3 )
      exitfunction 0
   endif

   rem make sure animation is Active
   if Animation( n ).Active < 2
      if Animation.logging = 1 then AddTextToConsole( "Animation " + str$( n ) + " not Active!" , 0xFFFF0000 , 3 )
      exitfunction 0
   endif

endfunction 1

function ObjectFrame( Obj )

   rem local variables
   local n as integer
	local f# as float

   rem find animation index of object
   for n = 0 to Animation.CurrentMax
      if Animation( n ).Obj = Obj then exit
   next n
   
   rem not found
   if n = Animation.CurrentMax + 1
      if Animation.logging = 1 then AddTextToConsole( "Object not Active!" , 0xFFFF0000 , 3 )
      exitfunction 0.0
   endif

   rem make sure animation is Active
   if Animation( n ).Active = 0
      if Animation.logging = 1 then AddTextToConsole( "Animation " + str$( n ) + " not Active!" , 0xFFFF0000 , 3 )
      exitfunction 0.0
   endif

	rem return value
	f# = Animation( n ).CurrentFrame#

endfunction f#

function ControlAnimation()

   rem local variables
   local n as integer
   
   rem loop through all Active animations
   for n = 0 to Animation.CurrentMax
      if Animation( n ).Active > 1
      
         rem increment frame
         inc Animation( n ).CurrentFrame# , Animation( n ).Speed# * TBM.delta#
         
         rem play object
         if Animation( n ).Active = 2

            rem animation reaches end
            if Animation( n ).CurrentFrame# > Animation( n ).EndFrame#
               Animation( n ).CurrentFrame# = Animation( n ).EndFrame#
               Animation( n ).Active = 1
            endif
            if Animation( n ).CurrentFrame# < Animation( n ).StartFrame#
               Animation( n ).CurrentFrame# = Animation( n ).StartFrame#
               Animation( n ).Active = 1
            endif

         endif
         
         rem loop object
         if Animation( n ).Active = 3
            
            rem animation reaches end
            if Animation( n ).CurrentFrame# > Animation( n ).EndFrame#
               Animation( n ).CurrentFrame# = Animation( n ).StartFrame#
            endif
            if Animation( n ).CurrentFrame# < Animation( n ).StartFrame#
               Animation( n ).CurrentFrame# = Animation( n ).EndFrame#
            endif
         endif
         
         rem update object frame
         set object frame Animation( n ).Obj , Animation( n ).CurrentFrame#

      endif
   next n

endfunction
rem ---------------------------------------------------------------------------
rem GUI - handles the grahpical user interface
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant GUIBindUnitMax 500

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type ButtonVT
   Clicked                          			as integer
endtype

type GUIVT
	logging                          			as integer
	MouseClickInvalid                			as integer
	CurrentMax											as integer
	CurrentUnitBindMax								as integer
endtype

type GUIAT
	Active                           			as integer
	pos                              			as vec2
	EndPos                          	 			as vec2
	IMG                              			as word
	GlowIMG                          			as word
	PressIMG                         			as word
	LockedIMG                        			as word
	KeyBind                          			as byte
	Locked                           			as integer
	ID                               			as integer
	BindCount                        			as integer
	BindKeyPressed                   			as integer
	Ability                          			as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitGUI()
	
	rem local variables
	local g 												as integer
	local b 												as integer

	rem debug
	DebugOutput( 0 , "Initialising GUI" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global GUI                       			as GUIVT
	global Button                    			as ButtonVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------
	
	global dim GUI()									as GUIAT
	global dim GUIBindUnit() 						as integer
	
	Button.Clicked = -1
	GUI.CurrentMax = -1
	GUI.CurrentUnitBindMax = -1

endfunction

function GUIAddStaticImage( Filename$ , x , y , ID )
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIAddStaticImage " + Filename$ + "," + str$(x) + "," + str$(y) , 0xFF00FFFF , 0 )
	
	rem check if file exists
	if file exist( Filename$ ) = 0
		if GUI.logging = 1 then AddTextToConsole( "File does not exist!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variable
	local n as integer
	
	rem find free slot
	for n = 0 to GUI.CurrentMax
		if GUI( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = GUI.CurrentMax + 1
		array insert at bottom GUI()
		inc GUI.CurrentMax
	endif
	
	rem load image
	GUI( n ).IMG = find free image()
	LoadImage( Filename$ , GUI( n ).IMG )
	
	rem scale to fit screen resolution
	ik resize image GUI( n ).IMG , (image width( GUI( n ).IMG ) * scw) / 1600.0 , (image height( GUI( n ).IMG) * sch) / 1200.0 , 1
	
	rem set values
	GUI( n ).Active = 2
	GUI( n ).pos.x = (x * scw) / 1600.0
	GUI( n ).pos.y = (y * sch) / 1200.0
	GUI( n ).EndPos.x = GUI( n ).pos.x + image width( GUI( n ).IMG )
	GUI( n ).EndPos.y = GUI( n ).pos.y + image height( GUI( n ).IMG )
	GUI( n ).BindCount = -1
	GUI( n ).Ability = 0
	if ID = -1 then GUI( n ).ID = n else GUI( n ).ID = ID
	
endfunction n

function GUIDestroyElement( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIDestroyElement " + str$(ID) , 0xFF00FFFF , 0 )
	
	rem find gui with that ID
	for n = 0 to GUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = GUI.CurrentMax + 1
		if GUI.logging = 1 then AddTextToConsole( "ID not found!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if GUI is active
	if GUI( n ).Active < 2
		if GUI.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem unbind anything from it
	for b = 0 to GUI.CurrentUnitBindMax
		GUIBindUnit( n , b ) = -1
	next b
	GUI( n ).BindCount = -1
	
	rem destroy
	if GUI( n ).Active = 2 then delete image GUI( n ).IMG
	if GUI( n ).Active = 3
		delete image GUI( n ).IMG
		delete image GUI( n ).GlowIMG
		delete image GUI( n ).PressIMG
		delete image GUI( n ).LockedIMG
	endif
	GUI( n ).Active = 0
	
endfunction n

function GUIAddButton( BackFilename$ , GlowFilename$ , PressFilename$ , LockedFilename$ , x , y , KeyBind , ID )
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIAddButton " + Filename$ + "," + GlowFilename$ + "," + PressFilename$ + str$(x) + "," + str$(y) + "," + str$(KeyBind) + "," + str$(ID) , 0xFF00FFFF , 0 )
	
	rem check if files exist
	if file exist( BackFilename$ ) = 0 or file exist( GlowFilename$ ) = 0 or file exist( PressFilename$ ) = 0 or file exist( LockedFilename$ ) = 0
		if GUI.logging = 1 then AddTextToConsole( "File does not exist!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to GUI.CurrentMax
		if GUI( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = GUI.CurrentMax + 1
		array insert at bottom GUI()
		inc GUI.CurrentMax
	endif
	
	rem load image
	GUI( n ).IMG = find free image()
	LoadImage( BackFilename$ , GUI( n ).IMG )
	GUI( n ).GlowIMG = find free image()
	LoadImage( GlowFilename$ , GUI( n ).GlowIMG )
	GUI( n ).PressIMG = find free image()
	LoadImage( PressFilename$ , GUI( n ).PressIMG )
	GUI( n ).LockedIMG = find free image()
	LoadImage( LockedFilename$ , GUI( n ).LockedIMG )
	
	rem resize images
	ik resize image GUI( n ).IMG , (image width(GUI( n ).IMG) * scw) / 1600.0 , (image height(GUI( n ).IMG) * sch) / 1200.0 , 1
	ik resize image GUI( n ).GlowIMG , (image width(GUI( n ).GlowIMG) * scw) / 1600.0 , (image height(GUI( n ).GlowIMG) * sch) / 1200.0 , 1
	ik resize image GUI( n ).PressIMG , (image width(GUI( n ).PressIMG) * scw) / 1600.0 , (image height(GUI( n ).PressIMG) * sch) / 1200.0 , 1
	ik resize image GUI( n ).LockedIMG , (image width(GUI( n ).LockedIMG) * scw) / 1600.0 , (image height(GUI( n ).LockedIMG) * sch) / 1200.0 , 1
	
	rem set values
	GUI( n ).Active = 3
	GUI( n ).pos.x = (x * scw) / 1600.0
	GUI( n ).pos.y = (y * sch) / 1200.0
	GUI( n ).EndPos.x = GUI( n ).pos.x + image width( GUI( n ).IMG )
	GUI( n ).EndPos.y = GUI( n ).pos.y + image height( GUI( n ).IMG )
	GUI( n ).Locked = 0
	GUI( n ).BindCount = -1
	GUI( n ).KeyBind = KeyBind
	GUI( n ).Ability = 0
	if ID = -1 then GUI( n ).ID = n else GUI( n ).ID = ID
	
endfunction n

function GUILockButton( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUILockButton " + str$(ID) , 0xFF00FFFF , 0 )
	
	rem find the button with that ID
	for n = 0 to GUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = GUI.CurrentMax + 1
		if GUI.logging = 1 then AddTextToConsole( "ID not found!" , 0xFFFF00000 , 3 )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		if GUI.logging = 1 then AddTextToConsole( "GUI element not in correct state!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem lock
	GUI( n ).Locked = 1
	
endfunction n

function GUIUnlockButton( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIUnlockButton " + str$(ID) , 0xFF00FFFF , 0 )
	
	rem find the button with that ID
	for n = 0 to GUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = GUI.CurrentMax + 1
		if GUI.logging = 1 then AddTextToConsole( "ID not found!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		if GUI.logging = 1 then AddTextToConsole( "GUI element not in correct state!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem unlock
	GUI( n ).Locked = 0

endfunction n

function GUIHideButton( n )
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIHideButton " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if GUI( n ).Active < 2
		if GUI.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).Active = 4
	
endfunction n

function GUIShowButton( n )
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIHideButton " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if GUI( n ).Active < 2
		if GUI.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).Active = 3
	
endfunction n

function GUIBindButtonToUnit( ID , n )
	
	rem local variables
	local g as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIBindButtonToUnit " + str$(ID) + "," + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if GUI.logging = 1 or Unit.logging = 1 then AddTextToConsole( "Unit or Button not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem find ID to gui element
	for g = 0 to GUI.CurrentMax
		if GUI( g ).ID = ID then exit
	next g
	
	rem not found
	if g = GUI.CurrentMax + 1
		if GUI.logging = 1 or Unit.logging = 1 then AddTextToConsole( "Button ID not found!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif

	rem find or create binding slot
	inc GUI( g ).BindCount
	if GUI( g ).BindCount > GUI.CurrentUnitBindMax
		inc GUI.CurrentUnitBindMax
		dim GUIBindUnit( GUI.CurrentMax , GUI.CurrentUnitBindMax ) as integer
	endif
	
	rem bind
	GUIBindUnit( g , GUI( g ).BindCount ) = n
	
endfunction ID

function GUIUnbindUnit( n , b )
	
	rem local variables
	local s as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIUnbindUnit " + str$(n) + "," + str$(b) , 0xFF00FFFF , 0 )
	
	rem shift binding stack down
	for s = b + 1 to GUI( n ).BindCount
		GUIBindUnit( n , s - 1 ) = GUIBindUnit( n , s )
	next s
	if GUI( n ).BindCount > -1 then dec GUI( n ).BindCount
	
endfunction

function GUIPositionButton( ID , x , y )
	
	rem local variables
	local n as integer
	
	rem logging
	if GUI.logging = 1 then AddTextToConsole( "GUIPositionButton " + str$(ID) , 0xFF00FFFF , 0 )
	
	rem search for button with that ID
	for n = 0 to GUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = GUI.CurrentMax + 1
		if GUI.logging = 1 then AddTextToConsole( "ID not found!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		if GUI.logging = 1 then AddTextToConsole( "GUI element not in correct state!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem reposition
	GUI( n ).pos.x = x
	GUI( n ).pos.y = y
	
endfunction n

function ControlGUI()
	
	rem local variables
   local n as integer
	local u as integer
	local a as integer
	local success as integer
	
	rem reset clicked button
	rem Button.Clicked = -1
	
	rem reset invalid mouse clicks
	GUI.MouseClickInvalid = 0

	rem loop through all active 
   for n = 0 to GUI.CurrentMax
		
		rem static image
		if GUI( n ).Active = 2
			
			rem paste static image
			paste image GUI( n ).IMG , GUI( n ).pos.x , GUI( n ).pos.y , 1
			
			rem check if mouse is invalid
			if Mouse.x > GUI( n ).pos.x and Mouse.x < GUI( n ).EndPos.x
				if Mouse.y > GUI( n ).pos.y and Mouse.y < GUI( n ).EndPos.y then GUI.MouseClickInvalid = 1
			endif
			
		endif
		
		rem button
		if GUI( n ).Active = 3
			
			rem check if button is locked
			if GUI( n ).Locked = 1
				paste image GUI( n ).LockedIMG , GUI( n ).pos.x , GUI( n ).pos.y , 1
			else
			
				rem control normal, glow, and pressed buttons
				if keystate( GUI( n ).KeyBind ) = 0
					if Mouse.x > GUI( n ).pos.x and Mouse.x < GUI( n ).EndPos.x and Mouse.y > GUI( n ).pos.y and Mouse.y < GUI( n ).EndPos.y
						paste image GUI( n ).GlowIMG , GUI( n ).pos.x , GUI( n ).pos.y , 1
						if Mouse.click = 1 then Button.Clicked = n
					else
						paste image GUI( n ).IMG , GUI( n ).pos.x , GUI( n ).pos.y , 1
					endif
					GUI( n ).BindKeyPressed = 0
				else
					if GUI( n ).BindKeyPressed = 0
						GUI( n ).BindKeyPressed = 1
						Button.Clicked = n
					endif
				endif
			endif
			
			rem paste press image if available
			if Button.Clicked = n
				paste image GUI( n ).PressIMG , GUI( n ).pos.x , GUI( n ).pos.y , 1
			endif
			
			rem lock the button
			GUI( n ).Locked = 1
			
			rem check if any of the units have an ability bound to this button -> unlock button
			for u = 0 to Unit.CurrentMax
				if Unit( u ).Selected > 1
					for a = 0 to MaxUnitAbility
						if UnitAbility( u , a ).BindButton = n and UnitAbility( u , a ).LockButton = 0
							GUI( n ).Locked = 0
							exit
						endif
					next a
				endif
				if GUI( n ).Locked = 0 then exit
			next u

			rem check if any of the bound units are selected
			for u = 0 to Unit.CurrentMax
				if Unit( u ).Selected > 1
					
					rem if a unit is selected that's not controlled by the player, disable button click
					if Unit( u ).Control <> UNITCONTROL_PLAYER then Button.Clicked = -1
					
					rem find bound unit
					for a = 0 to GUI( n ).BindCount
						
						rem bound unit found
						if GUIBindUnit( n , a ) = u then exit

					next a
					if a < GUI( n ).BindCount + 1 then exit
				endif
			next u
			if u = Unit.CurrentMax + 1
				
				rem disable button
				GUI( n ).Active = 4
				
			endif

		endif
		
		rem hidden button
		if GUI( n ).Active = 4
			
			rem check if any of the bound units are selected
			for u = 0 to Unit.CurrentMax
				if Unit( u ).Selected > 1
					for b = 0 to GUI( n ).BindCount
						if GUIBindUnit( n , b ) = u
							exit
						endif
					next b
					if b < GUI( n ).BindCount + 1 then exit
				endif
			next u
			if u < Unit.CurrentMax + 1

				rem show button
				GUI( n ).Active = 3

			endif
			
		endif
		
	next n

endfunction
rem ---------------------------------------------------------------------------
rem Click object - Effect when mouse clicks terrain
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type ClickObjVT
	logging                          			as integer
	CurrentMax											as integer
endtype

type ClickObjAT
	Active                           			as integer
	ConnectionActive                 			as integer
	pos                              			as vec3
	Life                             			as integer
	Obj                              			as word
	ConnectObj                       			as word
	Obj1                             			as word
	Obj2                             			as word
	color                            			as dword
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitClickObj()

	rem debug
	DebugOutput( 0 , "Initialising click object" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global ClickObj                  			as ClickObjVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------

	global dim ClickObj() 							as ClickObjAT
	
	rem initial values
	ClickObj.CurrentMax = -1

endfunction

function CreateClickObj( x# , y# , z# , Color , Life , ForceCreation )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "CreateClickObj " + str$(x#) + "," + str$(y#) + "," + str$(z#) + "," + str$(Color) + "," + str$(Life) + "," + str$(FrameStart) + "," + str$(FrameEnd) + "," + str$(FrameSpeed#) , 0xFF00FFFF , 0 )
	
	rem find a click object already there
	if ForceCreation = 0
		for n = 0 to ClickObj.CurrentMax
			if ClickObj( n ).Active = 2
				if ClickObj( n ).pos.x# = x# and ClickObj( n ).pos.z# = z#
					if ClickObj( n ).Life = Life then exitfunction n
					if ClickObj( n ).Life <> 0 and Life <> 0 then exitfunction n
				endif
			endif
		next n
	endif
	
	rem find free slot
	for n = 0 to ClickObj.CurrentMax
		if ClickObj( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = ClickObj.CurrentMax + 1
		array insert at bottom ClickObj()
		inc ClickObj.CurrentMax
	endif
	
	rem load object
	if ClickObj( n ).Active = 0
		ClickObj( n ).Obj = find free object()
		load object "media\objects\clickobj\clickobj.x" , ClickObj( n ).Obj
		ConvertObjectFVFTo338( ClickObj( n ).Obj )
		set object transparency ClickObj( n ).Obj , 3
		set object cull ClickObj( n ).Obj , 0
		disable object zwrite ClickObj( n ).Obj
		set object light ClickObj( n ).Obj , 0
	endif
	
	rem set object properties
	show object ClickObj( n ).Obj
	SetObjectDiffuse( ClickObj( n ).Obj , Color )
	position object ClickObj( n ).Obj , x# , y# , z#
	PlayObject( ClickObj( n ).Obj , 0 , 64 , 3 )
	
	rem set parameters
	ClickObj( n ).Active = 2
	if Life <> 0 then ClickObj( n ).Life = Life + timer() else ClickObj( n ).Life = 0
	ClickObj( n ).pos.x# = x#
	ClickObj( n ).pos.y# = y#
	ClickObj( n ).pos.z# = z#
	ClickObj( n ).Color = color
	
	rem if creation was forced, hide if another one is already at it's position
	if ForceCreation = 1
		for s = 0 to ClickObj.CurrentMax
			if s <> n
				if ClickObj( s ).Active > 1
					if ClickObj( s ).pos.x# = x# and ClickObj( s ).pos.z# = z# and ClickObj( s ).Life = 0
						HideClickObj( n )
						exit
					endif
				endif
			endif
		next s
	endif
	
endfunction n

function DestroyClickObj( n )
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "DestroyClickObj " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy
	hide object ClickObj( n ).Obj
	StopObject( ClickObj( n ).Obj )
	ClickObj( n ).Active = 1
	if ClickObj( n ).ConnectObj > 0 then hide object ClickObj( n ).ConnectObj
	ClickObj( n ).ConnectionActive = 0
	
endfunction n

function HideClickObj( n )
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "HideClickObj " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem hide
	hide object ClickObj( n ).Obj
	ClickObj( n ).Active = 3

endfunction n

function HideClickObjConnection( n )
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "HideClickObjConnection " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem hide
	if ClickObj( n ).ConnectObj > 0 then hide object ClickObj( n ).ConnectObj

endfunction n

function ShowClickObj( n )
	
	rem local variables
	local s as integer
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "ShowClickObj " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if any other click objects are at the same position
	for s = 0 to ClickObj.CurrentMax
		if s <> n
			if ClickObj( s ).Active = 2
				if ClickObj( s ).pos.x# = ClickObj( n ).pos.x# and ClickObj( s ).pos.z# = ClickObj( n ).pos.z# and ClickObj( s ).Life = ClickObj( n ).Life
					exitfunction -1
				endif
			endif
		endif
	next s
	
	rem show
	show object ClickObj( n ).Obj
	if ClickObj( n ).ConnectionActive = 1 then show object ClickObj( n ).ConnectObj
	ClickObj( n ).Active = 2
	
endfunction n

function ShowClickObjConnection( n )
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "ShowClickObjConnection" + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem show
	if ClickObj( n ).ConnectObj > 0 then show object ClickObj( n ).ConnectObj
	
endfunction n

function CreateClickObjConnection( n , Obj1 , Obj2 )

	rem local variables
	local pos1 as vec3
	local pos2 as vec3
	local angle# as float

	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "CreateClickObjConnection " + str$(n) + "," + str$(Obj1) + "," + str$(Obj2) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem create object if necessary
	if ClickObj( n ).ConnectObj = 0
		
		rem create object
		ClickObj( n ).ConnectObj = find free object()
		make object plain ClickObj( n ).ConnectObj , 1 , 1
		ConvertObjectFVFTo338( ClickObj( n ).ConnectObj )
		position object ClickObj( n ).ConnectObj , 0 , 0 , 0
		texture object ClickObj( n ).ConnectObj , IMGClickObjConnection
		set object transparency ClickObj( n ).ConnectObj , 1
		disable object zdepth ClickObj( n ).ConnectObj
		set object light ClickObj( n ).ConnectObj , 0
		set object cull ClickObj( n ).ConnectObj , 0
		set object radius ClickObj( n ).ConnectObj , -1
		
		rem edit diffuse data
		lock vertexdata for limb ClickObj( n ).ConnectObj , 0
			set vertexdata diffuse 0 , 0x00FFFFFF
			set vertexdata diffuse 1 , 0x00FFFFFF
			set vertexdata diffuse 2 , 0xFFFFFFFF
			set vertexdata diffuse 3 , 0x00FFFFFF
			set vertexdata diffuse 4 , 0xFFFFFFFF
			set vertexdata diffuse 5 , 0xFFFFFFFF
		unlock vertexdata
		
	endif
	
	rem object properties
	SetObjectDiffuse( ClickObj( n ).ConnectObj , ClickObj( n ).Color )
	show object ClickObj( n ).ConnectObj
	
	rem set active
	ClickObj( n ).ConnectionActive = 1
	ClickObj( n ).Obj1 = Obj1
	ClickObj( n ).Obj2 = Obj2
	
	rem position correctly
	ControlClickObj()

endfunction n

function DestroyClickObjConnection( n )
	
	rem logging
	if ClickObj.logging = 1 then AddTextToConsole( "DestroyClickObjConnection " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if ClickObj( n ).Active < 2
		if ClickObj.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy
	if ClickObj( n ).ConnectObj > 0 then hide object ClickObj( n ).ConnectObj
	ClickObj( n ).ConnectionActive = 0

endfunction n

function ControlClickObj()
	
	rem local variables
   local n as integer
	local pos1 as vec3
	local pos2 as vec3
	local angle# as float

	rem loop through all active 
   for n = 0 to ClickObj.CurrentMax
		if ClickObj( n ).Active = 2
			
			rem animation
			if ObjectPlaying( ClickObj( n ).Obj ) = 0 then PlayObject( ClickObj( n ).Obj , 0 , 64 , 3 )
			
			rem angle
			TiltObjectToTerrain( ClickObj( n ).Obj )
			
			rem life has run out
			if ClickObj( n ).Life <> 0
				if ClickObj( n ).Life - timer() < 0 then DestroyClickObj( n )
			endif
			
		endif
		
		rem connection
		if ClickObj( n ).Active > 1
			if ClickObj( n ).ConnectionActive = 1
				
				rem get object positions
				pos1.x# = object position x( ClickObj( n ).Obj1 )
				pos1.y# = object position y( ClickObj( n ).Obj1 )
				pos1.z# = object position z( ClickObj( n ).Obj1 )
				pos2.x# = object position x( ClickObj( n ).Obj2 )
				pos2.y# = object position y( ClickObj( n ).Obj2 )
				pos2.z# = object position z( ClickObj( n ).Obj2 )
				
				rem calculate angle
				angle# = wrapvalue( 270 - atanfull( pos1.z# - pos2.z# , pos1.x# - pos2.x# ) )
				
				rem object properties
				lock vertexdata for limb ClickObj( n ).ConnectObj , 0
					set vertexdata position 0 , 0-newxvalue( pos1.x# , angle# + 90 , 0.1 ) , pos1.y# , 0-newzvalue( pos1.z# , angle# + 90 , 0.1 )
					set vertexdata position 1 , 0-newxvalue( pos1.x# , angle# - 90 , 0.1 ) , pos1.y# , 0-newzvalue( pos1.z# , angle# - 90 , 0.1 )
					set vertexdata position 3 , 0-newxvalue( pos1.x# , angle# - 90 , 0.1 ) , pos1.y# , 0-newzvalue( pos1.z# , angle# - 90 , 0.1 )
					set vertexdata position 2 , 0-newxvalue( pos2.x# , angle# + 90 , 0.1 ) , pos2.y# , 0-newzvalue( pos2.z# , angle# + 90 , 0.1 )
					set vertexdata position 4 , 0-newxvalue( pos2.x# , angle# - 90 , 0.1 ) , pos2.y# , 0-newzvalue( pos2.z# , angle# - 90 , 0.1 )
					set vertexdata position 5 , 0-newxvalue( pos2.x# , angle# + 90 , 0.1 ) , pos2.y# , 0-newzvalue( pos2.z# , angle# + 90 , 0.1 )
				unlock vertexdata
				
			endif
		endif
		
	next n

endfunction

rem ---------------------------------------------------------------------------
rem Magic Missile ability
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant MagicMissileSpeed         2.2

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type MagicMissileVT
	logging                          as integer
	CurrentMax								as integer
endtype

type MagicMissileAT
	Active                           as integer
	pos                              as vec3
	dest                             as vec3
	Obj                              as word
	life                             as integer
	UnitID                           as integer
	FollowID                         as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitMagicMissile()

	rem debug
	DebugOutput( 0 , "Initialising Magic Missile" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global MagicMissile              as MagicMissileVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------

	global dim MagicMissile() 			as MagicMissileAT
	
	rem initial values
	MagicMissile.CurrentMax = -1

endfunction

function CreateMagicMissile( UnitID , x# , y# , z# , UnitFollowID )
	
	rem local variables
	local n as integer
	
	rem logging
	if MagicMissile.logging = 1 then AddTextToConsole( "CreateMagicMissile " + str$(UnitID) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) + "," + str$(destx#) + "," + str$(desty#) + "," + str$(destz#) , 0xFF00FFFF , 0 )
	
	rem find free slot
	for n = 0 to MagicMissile.CurrentMax
		if MagicMissile( n ).Active < 2 then exit
	next n
	
	rem no free slot found, create
	if n = MagicMissile.CurrentMax + 1
		array insert at bottom MagicMissile()
		inc MagicMissile.CurrentMax
	endif
	
	rem load
	if MagicMissile( n ).Active = 0
		MagicMissile( n ).Obj = find free object()
		LoadObject( "media\objects\magicmissile\magicmissile.x" , MagicMissile( n ).Obj )
		set object transparency MagicMissile( n ).Obj , 2
		disable object zwrite MagicMissile( n ).Obj
		set object light MagicMissile( n ).Obj , 0
	endif
	
	rem object properties
	position object MagicMissile( n ).Obj , x# , y# , z#
	show object MagicMissile( n ).Obj
	LoopObject( MagicMissile( n ).Obj , 0 , 8 , 1.8 )
	
	rem set parameters
	MagicMissile( n ).Active = 2
	MagicMissile( n ).pos.x# = x#
	MagicMissile( n ).pos.y# = y#
	MagicMissile( n ).pos.z# = z#
	MagicMissile( n ).FollowID = UnitFollowID
	MagicMissile( n ).UnitID = UnitID
	MagicMissile( n ).life = timer() + 2000
	
endfunction n

function DestroyMagicMissile( n )
	
	rem logging
	if MagicMissile.logging = 1 then AddTextToConsole( "DestroyMagicMissile " + str$(n) , 0xFF00FFFF , 0 )
	
	rem make sure active
	if MagicMissile( n ).Active < 2
		if MagicMissile.logging = 1 then AddTextToConsole( "Not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy
	StopObject( MagicMissile( n ).Obj )
	hide object MagicMissile( n ).Obj
	MagicMissile( n ).Active = 1
	
endfunction n

function ControlMagicMissile()
	
	rem local variables
   local n as integer
	local u as integer

	rem loop through all active 
   for n = 0 to MagicMissile.CurrentMax
		if MagicMissile( n ).Active = 2
			
			rem get destination coordinates
			MagicMissile( n ).dest = Unit( MagicMissile( n ).FollowID ).pos
			
			rem get target vector
			set vector3 1 , MagicMissile( n ).dest.x# - MagicMissile( n ).pos.x# , MagicMissile( n ).dest.y# - MagicMissile( n ).pos.y# , MagicMissile( n ).dest.z# - MagicMissile( n ).pos.z#
			normalize vector3 1 , 1
			
			rem move missile towards target
			inc MagicMissile( n ).pos.x# , x vector3( 1 ) * MagicMissileSpeed * TBM.delta#
			inc MagicMissile( n ).pos.y# , y vector3( 1 ) * MagicMissileSpeed * TBM.delta#
			inc MagicMissile( n ).pos.z# , z vector3( 1 ) * MagicMissileSpeed * TBM.delta#
			
			rem update positions
			position object MagicMissile( n ).Obj , MagicMissile( n ).pos.x# , MagicMissile( n ).pos.y# , MagicMissile( n ).pos.z#
			point object MagicMissile( n ).Obj , MagicMissile( n ).dest.x# , MagicMissile( n ).dest.y# , MagicMissile( n ).dest.z#
			
			rem check if missile does any damage to units
			for u = 0 to Unit.CurrentMax
				if Unit( u ).Active > 1
					if MagicMissile( n ).UnitID <> u
						if Unit( u ).Control <> Unit( MagicMissile( n ).UnitID ).Control
							if (MagicMissile( n ).pos.x# - Unit( u ).pos.x#)^2 + (MagicMissile( n ).pos.z# - Unit( u ).pos.z#)^2 < (Unit( u ).Size#/3)^2
								
								rem damage unit
								DamageUnit( u , UnitAbility( MagicMissile( n ).UnitID , UNITABILITY_MAGIC_MISSILE ).HealthDamage# , UnitAbility( MagicMissile( n ).UnitID , UNITABILITY_MAGIC_MISSILE ).ManaDamage# )
								
								rem destroy missile
								DestroyMagicMissile( n )
								
							endif
						endif
					endif
				endif
			next u
			
			rem runs out of life
			if MagicMissile( n ).life - timer() < 0 then DestroyMagicMissile( n )
			
		endif
	next n

endfunction

rem ---------------------------------------------------------------------------
rem Teleportation effect
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type TeleportEffectVT
	logging                                as integer
	CurrentMax 										as integer
endtype

type TeleportEffectAT
	Active                                 as integer
	UnitID                                 as integer
	VertexCount                            as integer
	CurrentVertex#                         as float
	VertexSpeed#                           as float
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitTeleportEffect()

	rem debug
	DebugOutput( 0 , "Initialising Teleport effect" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global TeleportEffect                  as TeleportEffectVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------

	global dim TeleportEffect() 				as TeleportEffectAT
	
	rem initial values
	TeleportEffect.CurrentMax = -1

endfunction

function CreateTeleportEffect( UnitID , size# , x# , y# , z# )
	
	rem logging
	if TeleportEffect.logging = 1 then AddTextToConsole( "CreateTeleportEffect " + str$(Obj) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) , 0xFF00FFFF , 0 )
	
	rem make sure unit supports teleporting
	if Unit( UnitID ).TeleportObj = 0
		if TeleportEffect.logging = 1 then AddTextToConsole( "Unit doesn't support teleporting!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem local variables
	local n as integer
	local i as integer
	
	rem find free slot
	for n = 0 to TeleportEffect.CurrentMax
		if TeleportEffect( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = TeleportEffect.CurrentMax + 1
		array insert at bottom TeleportEffect()
		inc TeleportEffect.CurrentMax
	endif
	
	rem set teleport object
	position object Unit( UnitID ).TeleportObj , x# , y# , z#
	yrotate object Unit( UnitID ).TeleportObj , limb angle y( Unit( UnitID ).Obj , 0 )
	show object Unit( UnitID ).TeleportObj
	
	rem set values
	TeleportEffect( n ).Active = 2
	TeleportEffect( n ).UnitID = UnitID
	TeleportEffect( n ).CurrentVertex# = 0.0
	
	rem process vertex list and sort so higher positioned vertices are first
	lock vertexdata for limb Unit( UnitID ).TeleportObj , 0
		for i = 0 to get vertexdata vertex count() - 1
			set vertexdata diffuse i , 0xFFFFFFFF
		next i
		TeleportEffect( n ).VertexSpeed# = i / 100
	unlock vertexdata

endfunction n

function DestroyTeleportEffect( n )
	
	rem logging
	if TeleportEffect.logging = 1 then AddTextToConsole( "DestroyTeleportEffect " + str$(n) , 0xFF00FFFF , 0 )
	
	rem check if activ
	if TeleportEffect( n ).Active < 2
		if TeleportEffect.logging = 1 then AddTextToConsole( "Teleport effect not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy
	hide object Unit( TeleportEffect( n ).UnitID ).TeleportObj
	TeleportEffect( n ).Active = 0
	
endfunction n

function ControlTeleportEffect()
	
	rem local variables
   local n as integer

	rem loop through all active teleport effects
   for n = 0 to TeleportEffect.CurrentMax
		if TeleportEffect( n ).Active = 2

			lock vertexdata for limb Unit( TeleportEffect( n ).UnitID ).TeleportObj , 0
				for i = int(TeleportEffect( n ).CurrentVertex#) to int(TeleportEffect( n ).CurrentVertex# * TeleportEffect( n ).VertexSpeed# * TBM.delta#)
					if i > get vertexdata vertex count() - 1
						DestroyTeleportEffect( n )
						exit
					endif
					set vertexdata diffuse i , 0x00000000
				next i
				inc TeleportEffect( n ).CurrentVertex# , TeleportEffect( n ).VertexSpeed# * TBM.delta#
			unlock vertexdata

		endif
	next n

endfunction

rem ---------------------------------------------------------------------------
rem Unit formations
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User defined types
rem ---------------------------------------------------------------------------

type UnitFormationAT
	Active                           			as integer
	AveragePos                       			as vec3
	Count                            			as integer
	Speed#                           			as float
endtype

type UnitFormationListAAT
	Index                            			as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitUnitFormation()
	
	rem ---------------------------------------------------------------------------
	rem global arrays
	rem ---------------------------------------------------------------------------
	
	global dim UnitFormation() 					as UnitFormationAT
	global dim UnitFormationList( 500 , 500 ) as UnitFormationListAAT

endfunction

function _Unit_Calculate_Formation_Groups()
	
	rem local variables
	local n as integer
	local s as integer
	local r as integer
	local f# as float
	
	rem prepare average data so other units can be removed/added
	for s = 0 to Unit.CurrentFormationMax
		UnitFormation( s ).Count = 0
		UnitFormation( s ).AveragePos.x# = 0.0
		UnitFormation( s ).AveragePos.z# = 0.0
	next s
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1 and Unit( n ).UseFormation > -1
			
			rem if unit is selected, it must be removed from it's formation so it can join potential other formations
			if Unit( n ).Selected > 1
				RemoveUnitFromFormation( n , Unit( n ).UseFormation )
			else
				
				rem if the unit is not selected and doesn't have a path, it must be removed from it's formation to clear space
				if Unit( n ).CurrentMaxPath = -1
					RemoveUnitFromFormation( n , Unit( n ).UseFormation )
				
				rem if unit does have an active path, it must remain in it's formation
				else
					inc UnitFormation( Unit( n ).UseFormation ).AveragePos.x# , Unit( n ).pos.x#
					inc UnitFormation( Unit( n ).UseFormation ).AveragePos.z# , Unit( n ).pos.z#
					inc UnitFormation( Unit( n ).UseFormation ).Count
				endif
			endif
		endif
	next n
	
	rem calculate formations
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1
			if Unit( n ).UseFormation = -1
				if Unit( n ).Selected > 1

					rem find an existing formation to join
					for s = 0 to Unit.CurrentFormationMax
						if UnitFormation( s ).Active = 2
							if (Unit( n ).pos.x# - (UnitFormation( s ).AveragePos.x#/UnitFormation( s ).Count))^2 + (Unit( n ).pos.z# - (UnitFormation( s ).AveragePos.z#/UnitFormation( s ).Count))^2 < 30.0
								
								rem check if the other units already in formation are selected
								for r = 0 to Unit.CurrentMax
									if Unit( r ).Active > 1 and Unit( r ).UseFormation = s
										if Unit( r ).Selected < 2 then exit
									endif
								next r
								if r = Unit.CurrentMax + 1
								
									rem new count
									inc UnitFormation( s ).Count
									
									rem add unit to formation
									Unit( n ).UseFormation = s
									Unit( n ).FormationPos = Unit( n ).pos
									inc UnitFormation( s ).AveragePos.x# , Unit( n ).pos.x#
									inc UnitFormation( s ).AveragePos.z# , Unit( n ).pos.z#
									f# = ((Unit( n ).HeightOffset#<0.2) * Unit( n ).GroundSpeed#) + ((Unit( n ).HeightOffset#>=0.2) * Unit( n ).AirSpeed#)
									if f# < UnitFormation( s ).Speed# then UnitFormation( s ).Speed# = f#
									
									rem finished
									exit
									
								endif
							endif
						endif
					next s

					rem no formation was found
					if s = Unit.CurrentFormationMax + 1
						
						rem find a free slot
						for s = 0 to Unit.CurrentFormationMax
							if UnitFormation( s ).Active < 2 then exit
						next s
						
						rem no free slot, create
						if s = Unit.CurrentFormationMax + 1
							inc Unit.CurrentFormationMax
							array insert at bottom UnitFormation()
						endif
						
						rem add unit to formation
						Unit( n ).UseFormation = s
						Unit( n ).FormationPos = Unit( n ).pos
						UnitFormation( s ).Active = 2
						UnitFormation( s ).Count = 1
						UnitFormation( s ).AveragePos.x# = Unit( n ).pos.x#
						UnitFormation( s ).AveragePos.z# = Unit( n ).pos.z#
						UnitFormation( s ).Speed# = ((Unit( n ).HeightOffset#<0.2) * Unit( n ).GroundSpeed#) + ((Unit( n ).HeightOffset#>=0.2) * Unit( n ).AirSpeed#)

					endif
					
				endif
			endif
		endif
	next n
	
	rem calculate average
	for n = 0 to Unit.CurrentFormationMax
		if UnitFormation( n ).Active = 2
			UnitFormation( n ).AveragePos.x# = UnitFormation( n ).AveragePos.x# / UnitFormation( n ).Count
			UnitFormation( n ).AveragePos.z# = UnitFormation( n ).AveragePos.z# / UnitFormation( n ).Count
		endif
	next n
	
endfunction

function RemoveUnitFromFormation( n , Formation )
	
	rem local variables
	local s as integer
	
	rem remove unit from formation
	Unit( n ).UseFormation = -1
	
	rem count how many units are left in formation
	for s = 0 to Unit.CurrentMax
		if Unit( s ).Active > 1
			if Unit( s ).UseFormation = Formation then exit
		endif
	next s

	rem none left, destroy formation
	if s = Unit.CurrentMax + 1
		UnitFormation( Formation ).Active = 0
	endif
	
endfunction

function ControlFormation()
	
	rem local variables
	local n as integer
	
	rem reset average data
	for n = 0 to Unit.CurrentFormationMax
		UnitFormation( n ).AveragePos.x# = 0.0
		UnitFormation( n ).AveragePos.z# = 0.0
		UnitFormation( n ).Count = 0
	next n
	
	rem gather unit data
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1
			if Unit( n ).UseFormation > -1
				inc UnitFormation( Unit( n ).UseFormation ).Averagepos.x# , Unit( n ).pos.x#
				inc UnitFormation( Unit( n ).UseFormation ).Averagepos.z# , Unit( n ).pos.z#
				inc UnitFormation( Unit( n ).UseFormation ).Count
			endif
		endif
	next n
	
	rem calculate average
	for n = 0 to Unit.CurrentFormationMax
		if UnitFormation( n ).Active = 2
			UnitFormation( n ).AveragePos.x# = UnitFormation( n ).AveragePos.x# / UnitFormation( n ).Count
			UnitFormation( n ).AveragePos.z# = UnitFormation( n ).AveragePos.z# / UnitFormation( n ).Count
		endif
	next n
	
	rem draw formations
	if Unit.DrawFormation = 1 then _Unit_Draw_Formations()
	
endfunction

function _Unit_Draw_Formations()
	
	rem local variables
	local n as integer
	
	rem draw average positions
	for n = 0 to Unit.CurrentFormationMax
		if UnitFormation( n ).Active > 1
			position object 1000 , UnitFormation( n ).AveragePos.x# , 0 , UnitFormation( n ).AveragePos.z#
			a2fillcircle object screen x(1000) , object screen y(1000) , 4 , 0xFFFF8000
			a2text FontID , object screen x(1000) , object screen y(1000) + 8 , str$(n) , 0xFFFFFFFF
		endif
	next n
	
endfunction
rem ---------------------------------------------------------------------------
rem Unit Pathfinder
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type PathfinderAAAT
	pos                              			as vec3
	CurrentMaxWaypoint               			as integer
	ClickObjID                       			as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitUnitPath()

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------

	global dim UnitPath( 1 , 1 , 1 )				as PathfinderAAAT

endfunction

function UnitCalculatePath( n , StartX# , StartY# , EndX# , EndY#)
	
	rem local variables
	local sx as integer
	local sy as integer
	local ex as integer
	local ey as integer
	local success as integer
	local p as integer
	local r as integer
	local s as integer
	local x# as float
	local z# as float
	local nextx# as float
	local nextz# as float
	local saveCurrentPath as integer
	local saveCurrentWaypoint as integer
	local color as dword
	local angle# as float
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitCalculatePath " + str$(n) + "," + str$(EndX#) + "," + str$(EndY#) , 0xFF00FFFF , 0 )

	rem convert to tile coordinates
	ex = ((EndX# - World.PathFinder.StartX#) * World.PathFinder.ResolutionX) / (World.PathFinder.EndX# - World.PathFinder.StartX#)
	ey = ((EndY# - World.PathFinder.StartY#) * World.PathFinder.ResolutionY) / (World.PathFinder.EndY# - World.PathFinder.StartY#)
	sx = ((StartX# - World.PathFinder.StartX#) * World.PathFinder.ResolutionX) / (World.PathFinder.EndX# - World.PathFinder.StartX#)
	sy = ((StartY# - World.PathFinder.Starty#) * World.PathFinder.ResolutionY) / (World.PathFinder.EndY# - World.PathFinder.StartY#)
	
	rem check if coordinates are in range
	if sx > -1 and sy > -1 and sx < World.PathFinder.ResolutionX + 1 and sy < World.PathFinder.ResolutionY + 1
		if ex > -1 and ey > -1 and ex < World.PathFinder.ResolutionX + 1 and ey < World.PathFinder.ResolutionY + 1

			rem logging
			success = 1
			if World.PathFinder.ID > -1
				if Unit.logging = 1 then AddTextToConsole( "Path from " + str$(sx) + "," + str$(sy) + " to " + str$(ex) + "," + str$(ey) , 0xFF00FFFF , 0 )
				
				rem if unit is on an invalid position, find a surrounding tile
				if iaa_get pathmap value( World.PathFinder.ID , sx , sy )
					if _Pathfinder_Find_Free_Surrounding( sx , sy )
						sx = Misc.pos2D.x
						sy = Misc.pos2D.y
					endif
				endif
				
				rem calculate path
				success = iaa_search path( World.PathFinder.ID , 0 , sx , sy , ex , ey )
			endif
				
			rem compile to way points
			if success = 1

				rem pathfinder has been set up
				if World.PathFinder.ID > -1
					success = iaa_compile path to checkpoints( World.PathFinder.ID , 0 )
					
					rem resize array if necessary
					saveCurrentPath = Unit( n ).CurrentMaxPath + 1
					saveCurrentWaypoint = 0
					if saveCurrentPath > Unit.CurrentPathMax
						_ResizeArray_UnitPath( Unit.CurrentMax , saveCurrentPath , Unit.CurrentWaypointMax )
					endif
					
					rem resize array for waypoints if needed
					if iaa_get total checkpoints( World.PathFinder.ID , 0 )+1 > Unit.CurrentWaypointMax
						_ResizeArray_UnitPath( Unit.CurrentMax , Unit.CurrentPathMax , iaa_get total checkpoints( World.Pathfinder.ID , 0 )+1 )
					endif
					
					rem first waypoint
					UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# = StartX#
					UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# = StartY#
					
					rem store all waypoints into an array
					for p = 0 to iaa_get total checkpoints( World.PathFinder.ID , 0 ) - 1
						x# = World.PathFinder.StartX# + (((World.PathFinder.EndX# - World.PathFinder.StartX#) * iaa_get checkpoint x( World.PathFinder.ID , 0 , p ) ) / World.PathFinder.ResolutionX)
						z# = World.PathFinder.StartY# + (((World.PathFinder.EndY# - World.PathFinder.StartY#) * iaa_get checkpoint y( World.PathFinder.ID , 0 , p ) ) / World.PathFinder.ResolutionY)
						inc saveCurrentWaypoint
						UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# = x#
						UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# = z#
					next p
					
					rem last waypoint
					inc saveCurrentWaypoint
					UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# = EndX#
					UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# = EndY#
					
					rem optimize waypoints
					for p = 0 to saveCurrentWaypoint
						
						rem raycast to next waypoints until no collision is found
						for s = p + 2 to saveCurrentWaypoint
							if SC_RayCastGroup( COL_PATHFINDER , UnitPath( n , saveCurrentPath , p ).pos.x# , World.PathFinder.Threshold , UnitPath( n , saveCurrentPath , p ).pos.z# , UnitPath( n , saveCurrentPath , s ).pos.x# , World.PathFinder.Threshold , UnitPath( n , saveCurrentPath , s ).pos.z# , 0 ) = 0
								
								rem waypoint not needed, remove
								dec s
								for r = s to saveCurrentWaypoint - 1
									UnitPath( n , saveCurrentPath , r ).pos = UnitPath( n , saveCurrentPath , r + 1).pos
								next r
								dec saveCurrentWaypoint
								exit
							endif
						next s
						
					next p
					
					rem check if second last waypoint is needed
					if saveCurrentWaypoint > 1
						if SC_RayCastGroup( COL_PATHFINDER , UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 2 ).pos.x# , World.PathFinder.Threshold , UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 2 ).pos.z# , UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# , World.PathFinder.Threshold , UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# , 0 ) = 0
							UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 1 ).pos = UnitPath( n , saveCurrentPath , saveCurrentWaypoint).pos
							dec saveCurrentWaypoint
						endif
					endif
				
				rem pathfinder has not been set up
				else
				
					rem resize array if necessary
					saveCurrentPath = Unit( n ).CurrentMaxPath + 1
					if saveCurrentPath > Unit.CurrentPathMax
						_ResizeArray_UnitPath( Unit.CurrentMax , saveCurrentPath , Unit.CurrentWaypointMax )
					endif
					
					rem resize array for waypoints if needed
					if 1 > Unit.CurrentWaypointMax
						_ResizeArray_UnitPath( Unit.CurrentMax , Unit.CurrentPathMax , 1 )
					endif
				
					rem first waypoint
					UnitPath( n , saveCurrentPath , 0 ).pos.x# = StartX#
					UnitPath( n , saveCurrentPath , 0 ).pos.z# = StartY#

					rem last waypoint
					UnitPath( n , saveCurrentPath , 1 ).pos.x# = EndX#
					UnitPath( n , saveCurrentPath , 1 ).pos.z# = EndY#
					
					rem current waypoint
					saveCurrentWaypoint = 1
				
				endif
				
				rem check if unit can use formations
				if Unit( n ).UseFormation > -1

					rem get angle offset
					if saveCurrentWaypoint > 0
						
						rem calculate angle offset
						angle# = 270.0 - atanfull( UnitPath( n , 0 , 0 ).pos.z# - UnitPath( n , 0 , 1 ).pos.z# , UnitPath( n , 0 , 0 ).pos.x# - UnitPath( n , 0 , 1 ).pos.x# )
						dec angle# , 270 - atanfull( UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 1 ).pos.z# - UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# , UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 1 ).pos.x# - UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# )

						rem subtract average position
						x# = Unit( n ).FormationPos.x# - UnitFormation( Unit( n ).UseFormation ).AveragePos.x#
						z# = Unit( n ).FormationPos.z# - UnitFormation( Unit( n ).UseFormation ).AveragePos.z#
						
						rem perform rotation around y axis using a rotation matrix
						remstart
								  / cos(a)   0        -sin(a)  \
						Ry(a) = | 0        1        0        |
								  \ sin(a)   0        cos(a)   /
						remend
						nx# = (x#*cos(angle#)) - (z#*sin(angle#))
						nz# = (x#*sin(angle#)) + (z#*cos(angle#))
						
						rem add last waypoint position
						x# = nx# + UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x#
						z# = nz# + UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z#
						
						rem make sure new coordinates are valid by raycasting from last waypoint
						if SC_RayCastGroup( COL_PATHFINDER , UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 1 ).pos.x# , World.PathFinder.Threshold , UnitPath( n , saveCurrentPath , saveCurrentWaypoint - 1 ).pos.z# , x# , World.PathFinder.Threshold , z# , 0 ) = 0
							
							rem if valid, replace last waypoint positions with these
							UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.x# = x#
							UnitPath( n , saveCurrentPath , saveCurrentWaypoint ).pos.z# = z#
							
						endif
						
					endif
					
				endif
				
				rem finish saving wayopint data
				inc Unit( n ).CurrentMaxPath
				UnitPath( n , saveCurrentPath , 0 ).CurrentMaxWaypoint = saveCurrentWaypoint
				if Unit.logging = 1
					AddTextToConsole( "saveCurrentPath: " + str$(saveCurrentPath) , 0xFF00FFFF , 0 )
					AddTextToConsole( "saveCurrentWaypoint: " + str$(saveCurrentWaypoint) , 0xFF00FFFF , 0 )
				endif
				
				rem color of path
				if Unit( n ).AttackActive = 0
					color = 0xFF00FF60
				else
					color = 0xFFFF4040
				endif
				
				rem if this is the first path, create short click object
				if saveCurrentPath = 0
					CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 320 , 0 )
					UnitPath( n , 0 , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 1 )
					HideClickObj( UnitPath( n , 0 , 0 ).ClickObjID )
				endif
				
				rem second path
				if saveCurrentPath = 1
					
					rem next click object
					ShowClickObj( UnitPath( n , 0 , 0 ).ClickObjID )
					UnitPath( n , 1 , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 0 )
					
					rem create connections
					CreateClickObjConnection( UnitPath( n , 0 , 0 ).ClickObjID , Unit( n ).Obj , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Obj )
					CreateClickObjConnection( UnitPath( n , 1 , 0 ).ClickObjID , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Obj , ClickObj( UnitPath( n , 1 , 0 ).ClickObjID ).Obj )
					
				endif
				
				rem rem more than 2 paths queued
				if saveCurrentPath > 1
					
					rem add next click object with connection
					UnitPath( n , saveCurrentPath , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 0 )
					CreateClickObjConnection( UnitPath( n , saveCurrentPath , 0 ).ClickObjID , ClickObj( UnitPath( n , saveCurrentPath - 1 , 0 ).ClickObjID ).Obj , ClickObj( UnitPath( n , saveCurrentPath , 0 ).ClickObjID ).Obj )
				
				endif

			endif

		endif
	endif
	
endfunction

function ResetUnitPath( n )

	rem local variables
	local s as integer
	local t as integer
	local u as integer
	
	rem destroy any click objects
	for s = 0 to Unit( n ).CurrentMaxPath
		if UnitPath( n , s , 0 ).ClickObjID > -1
			
			rem make sure click object is not attached to any other units
			for u = 0 to Unit.CurrentMax
				if Unit( u ).Active > 1 and u <> n
					for t = 0 to Unit( u ).CurrentMaxPath
						if UnitPath( u , t , 0 ).ClickObjID > -1
							if UnitPath( u , t , 0 ).ClickObjID = UnitPath( n , s , 0 ).ClickObjID then exit
						endif
					next t
					if t < Unit( u ).CurrentMaxPath + 1 then exit
				endif
			next u
			
			rem no other units found? Destroy
			if u = Unit.CurrentMax + 1
				DestroyClickObj( UnitPath( n , s , 0 ).ClickObjID )
				
			rem other unit found? Hide
			else
				HideClickObj( UnitPath( n , s , 0 ).ClickObjID )
				HideClickObjConnection( UnitPath( n , s , 0 ).ClickObjID )
			endif
			
			rem detach from path
			UnitPath( n , s , 0 ).ClickObjID = -1
			
		endif
	next s
	
	rem reset path
	Unit( n ).CurrentMaxPath = -1
	Unit( n ).CurrentWaypoint = 1
	Unit( n ).FollowUnitDelayTimer = timer()
	
endfunction

function HideUnitPath( n )
	
	rem local variables
	local s as integer
	local u as integer
	local t as integer
	
	remstart make sure click object is not attached to any other units
	for s = 0 to Unit( n ).CurrentMaxPath
		for u = 0 to Unit.CurrentMax
			if Unit( u ).Active > 1 and u <> n and Unit( n ).Selected > 1
				for t = 0 to Unit( u ).CurrentMaxPath
					if UnitPath( u , t , 0 ).ClickObjID > -1
						if UnitPath( u , t , 0 ).ClickObjID = UnitPath( n , s , 0 ).ClickObjID then exit
					endif
				next t
				if t < Unit( u ).CurrentMaxPath + 1 then exit
			endif
		next u
		if u < Unit.CurrentMax + 1 then exit
	next s
	remend
	
	rem no other units found? Hide
	rem if s = Unit( n ).CurrentMaxPath + 1
		for s = 0 to Unit( n ).CurrentMaxPath
			if UnitPath( n , s , 0 ).ClickObjID > -1
				HideClickObj( UnitPath( n , s , 0 ).ClickObjID )
				HideClickObjConnection( UnitPath( n , s , 0 ).ClickObjID )
			endif
		next s
	rem endif
	
endfunction

function HideUnitPaths()
	
	rem local variables
	local n as integer
	local s as integer
	
	rem hide any click objects
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1
			for s = 0 to Unit( n ).CurrentMaxPath
				if UnitPath( n , s , 0 ).ClickObjID > -1
					HideClickObj( UnitPath( n , s , 0 ).ClickObjID )
					HideClickObjConnection( UnitPath( n , s , 0 ).ClickObjID )
				endif
			next s
		endif
	next n
	
endfunction

function ShowUnitPath( n )
	
	rem local variables
	local s as integer
	
	rem show click objects if unit has more than 1 waypoint
	if Unit( n ).CurrentMaxPath > 0
		for s = 0 to Unit( n ).CurrentMaxPath
			if UnitPath( n , s , 0 ).ClickObjID > -1
				ShowClickObj( UnitPath( n , s , 0 ).ClickObjID )
				ShowClickObjConnection( UnitPath( n , s , 0 ).ClickObjID )
			endif
		next s
	endif
	
endfunction

function _Unit_Create_Ground_Path_With_Mouse( n )

   rem local variables
   local ex as integer
   local ey as integer
	
	rem only for player controlled units
	if Unit( n ).Control <> UNITCONTROL_PLAYER then exitfunction
	
	rem right click to move unit or left click if default attack button was clicked
	if (Mouse.click = 4 or (Mouse.Click = 1 and Unit.Ability.AllowLeftMouseClickForPath = 1)) and Mouse.Click3DFound = 1 and GUI.MouseClickInvalid = 0
		
		rem check if click coordinates are valid (no wall)
      ex = ((Mouse.Click3D.x# - World.PathFinder.StartX#) * World.PathFinder.ResolutionX) / (World.PathFinder.EndX# - World.PathFinder.StartX#)
      ey = ((Mouse.Click3D.z# - World.PathFinder.StartY#) * World.PathFinder.ResolutionY) / (World.PathFinder.EndY# - World.PathFinder.StartY#)
      if sx > -1 and sy > -1 and sx < World.PathFinder.ResolutionX + 1 and sy < World.PathFinder.ResolutionY + 1
         if ex > -1 and ey > -1 and ex < World.PathFinder.ResolutionX + 1 and ey < World.PathFinder.ResolutionY + 1
            if iaa_get pathmap value( World.PathFinder.ID , ex , ey ) <> 0 then exitfunction
         endif
      endif
         
		rem if the shiftkey isn't pressed, reset path (so no more are added in the list)
		if shiftkey() = 0
			ResetUnitPath( n )
		endif

		rem reset follow flag
		if Unit( n ).Ability.Active = UNITABILITY_MOVE then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_STOP then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_HOLD then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_FLY then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_LAND then Unit( n ).FollowUnit = -1
		if Mouse.Click = 4 then Unit( n ).FollowUnit = -1
		
		rem reset button flag
		Unit.PostResetButtonClicked = 1
		
		rem find paths
		if Unit( n ).CurrentMaxPath = -1
			UnitCalculatePath( n , Unit( n ).pos.x# , Unit( n ).pos.z# , Mouse.Click3D.x# , Mouse.Click3D.z# )
		else
			UnitCalculatepath( n , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.x# , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.z# , Mouse.Click3D.x# , Mouse.Click3D.z# )
		endif

	endif
				
endfunction

function _Unit_Create_Air_Path_With_Mouse( n )
	
	rem local variables
	local s as integer
	
	rem right click to move unit
	if Mouse.click = 4 and Mouse.Click3DFound = 1
		
		rem if the shiftkey isn't pressed, reset path (so no more are added in the list)
		if shiftkey() = 0
			ResetUnitPath( n )
		endif
		
		rem check if unit is in a formation with ground units
		for s = 0 to Unit.CurrentMax
			if s <> n
				if Unit( s ).Active > 1 and Unit( s ).HeightOffset# < 0.2
					if Unit( s ).UseFormation = Unit( n ).UseFormation then exit
				endif
			endif
		next s
		
		rem search for ground paths
		if s < Unit.CurrentMax + 1
			
			_Unit_Create_Ground_Path_With_Mouse( n )

		rem search for air paths
		else

			rem add new path
			inc Unit( n ).CurrentMaxPath
			
			rem resize array if necessary
			if Unit( n ).CurrentMaxPath > Unit.CurrentPathMax
				_ResizeArray_UnitPath( Unit.CurrentMax , Unit( n ).CurrentMaxPath , Unit.CurrentWaypointMax )
			endif
			
			rem resize array for waypoints if needed
			if 1 > Unit.CurrentWaypointMax
				_ResizeArray_UnitPath( Unit.CurrentMax , Unit.CurrentPathMax , 1 )
			endif
			
			rem starting position
			if Unit( n ).CurrentMaxPath = 0
				UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).pos = Unit( n ).pos
			else
				UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).pos = UnitPath( n , Unit( n ).CurrentMaxPath - 1 , 1 ).pos
			endif
			
			rem end position
			UnitPath( n , Unit( n ).CurrentMaxPath , 1 ).pos = Mouse.Click3D
			UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint = 1
			
			rem check if unit can use formations
			if Unit( n ).UseFormation > -1
				
				rem calculate angle offset
				angle# = 270.0 - atanfull( UnitPath( n , 0 , 0 ).pos.z# - UnitPath( n , 0 , 1 ).pos.z# , UnitPath( n , 0 , 0 ).pos.x# - UnitPath( n , 0 , 1 ).pos.x# )
				dec angle# , 270 - atanfull( UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint - 1 ).pos.z# - UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.z# , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint - 1 ).pos.x# - UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.x# )

				rem subtract average position
				x# = Unit( n ).FormationPos.x# - UnitFormation( Unit( n ).UseFormation ).AveragePos.x#
				z# = Unit( n ).FormationPos.z# - UnitFormation( Unit( n ).UseFormation ).AveragePos.z#
				
				rem perform rotation around y axis using a rotation matrix
				remstart
						  / cos(a)   0        -sin(a)  \
				Ry(a) = | 0        1        0        |
						  \ sin(a)   0        cos(a)   /
				remend
				nx# = (x#*cos(angle#)) - (z#*sin(angle#))
				nz# = (x#*sin(angle#)) + (z#*cos(angle#))
				
				rem add last waypoint position
				x# = nx# + UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.x#
				z# = nz# + UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.z#
				
				rem make sure new coordinates are valid by raycasting from last waypoint
				if SC_RayCastGroup( COL_PATHFINDER , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint - 1 ).pos.x# , World.PathFinder.Threshold , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint - 1 ).pos.z# , x# , World.PathFinder.Threshold , z# , 0 ) = 0
					
					rem if valid, replace last waypoint positions with these
					UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.x# = x#
					UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.z# = z#
					
				endif

			endif

			rem color of path
			if Unit( n ).AttackActive = 0
				color = 0xFF00FF60
			else
				color = 0xFFFF4040
			endif
			
			rem if this is the first path, create short click object
			if Unit( n ).CurrentMaxPath = 0
				CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 320 , 0 )
				UnitPath( n , 0 , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 1 )
				HideClickObj( UnitPath( n , 0 , 0 ).ClickObjID )
			endif
			
			rem second path
			if Unit( n ).CurrentMaxPath = 1
				
				rem next click object
				ShowClickObj( UnitPath( n , 0 , 0 ).ClickObjID )
				UnitPath( n , 1 , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 0 )
				
				rem create connections
				CreateClickObjConnection( UnitPath( n , 0 , 0 ).ClickObjID , Unit( n ).Obj , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Obj )
				CreateClickObjConnection( UnitPath( n , 1 , 0 ).ClickObjID , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Obj , ClickObj( UnitPath( n , 1 , 0 ).ClickObjID ).Obj )
				
			endif
			
			rem rem more than 2 paths queued
			if Unit( n ).CurrentMaxPath > 1
				
				rem add next click object with connection
				UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).ClickObjID = CreateClickObj( Mouse.Click3D.x# , Mouse.Click3D.y# , Mouse.Click3D.z# , color , 0 , 0 )
				CreateClickObjConnection( UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).ClickObjID , ClickObj( UnitPath( n , Unit( n ).CurrentMaxPath - 1 , 0 ).ClickObjID ).Obj , ClickObj( UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).ClickObjID ).Obj )
			
			endif
			
		endif
		
	endif
				
endfunction

function _Unit_Handle_Ground_Paths( n )
	
	rem check if unit has any paths queued
	if Unit( n ).CurrentMaxPath > -1
		
		rem calculate speed
		if Unit( n ).UseFormation = -1
			Unit( n ).CurrentSpeed# = curvevalue( Unit( n ).GroundSpeed# , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		else
			Unit( n ).CurrentSpeed# = curvevalue( UnitFormation( Unit( n ).UseFormation ).Speed# , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		endif
		
		rem handle paths
		_Unit_Handle_Paths( n )
	
	else
		
		rem slow unit down
		Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		
	endif
	
endfunction

function _Unit_Handle_Air_Paths( n )
	
	rem check if unit has any paths queued
	if Unit( n ).CurrentMaxPath > -1
		
		rem calculate speed
		if Unit( n ).UseFormation = -1
			Unit( n ).CurrentSpeed# = curvevalue( Unit( n ).AirSpeed# , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		else
			Unit( n ).CurrentSpeed# = curvevalue( UnitFormation( Unit( n ).UseFormation ).Speed# , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		endif
		
		rem handle paths
		_Unit_Handle_Paths( n )

	else
		
		rem slow unit down
		Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
		
	endif
			
endfunction

function _Unit_Handle_Paths( n )

	rem check if unit is evading
	if Unit( n ).EvadeUnit = 0
		
		rem rotate unit to next waypoint
		Unit( n ).angle.y# = curveangle( 270 - atanfull( Unit( n ).pos.z# - UnitPath( n , 0 , Unit( n ).CurrentWaypoint ).pos.z# , Unit( n ).pos.x# - UnitPath( n , 0 , Unit( n ).CurrentWaypoint ).pos.x# ) , Unit( n ).angle.y# , 1.0 / TBM.delta# )

	else
	
		rem rotate unit away from colliding unit
		Unit( n ).angle.y# = curveangle( Unit( n ).EvadeAngle# , Unit( n ).angle.y# , 0.5 / TBM.delta# )
		
		rem check if evade timer has expired
		if timer() - Unit( n ).EvadeUnitTimer > 400 then Unit( n ).EvadeUnit = 0
	endif
	
	rem check if unit has to evade another unit
	rem this only works if the unit is not attacking
	if Unit( n ).AttackActive = 0
		for sx = 0 to Unit.CurrentMax
			if sx <> n
				if Unit( sx ).Active > 1 and Unit( n ).Control <> Unit( sx ).Control and Unit( sx ).FollowUnit <> n
					if (Unit( sx ).pos.x# - Unit( n ).pos.x#)^2 + ((Unit( sx ).pos.y#+Unit( sx ).HeightOffset#) - (Unit( n ).pos.y#+Unit( sx ).HeightOffset#))^2 + (Unit( sx ).pos.z# - Unit( n ).pos.z#)^2 < (Unit( n ).size#*1.5)^2
						dist# = Unit( n ).angle.y# - (270 - atanfull( Unit( n ).pos.z# - Unit( sx ).pos.z# , Unit( n ).pos.x# - Unit( sx ).pos.x# ))
						if dist# < -180.0 then inc dist# , 360.0
						if CustomABS(dist#) < 45
							Unit( n ).EvadeUnit = 1
							Unit( n ).EvadeUnitTimer = timer()
							Unit( n ).EvadeAngle# = dist# + Unit( n ).angle.y#
						endif
					endif
				endif
			endif
		next sx
	endif
	
	rem arrived at waypoint? Set coordinates to next
	if (Unit( n ).pos.x# - UnitPath( n , 0 , Unit( n ).CurrentWaypoint).pos.x#)^2 + (Unit( n ).pos.z# - UnitPath( n , 0 , Unit( n ).CurrentWaypoint).pos.z#)^2 < (Unit( n ).GroundSpeed#*2)^2
		inc Unit( n ).CurrentWaypoint
	endif
	
	rem last waypoint reached
	if Unit( n ).CurrentWaypoint > UnitPath( n , 0 , 0 ).CurrentMaxWaypoint
		
		rem destroy click object
		if UnitPath( n , 0 , 0 ).ClickObjID > -1
			
			rem check if any other units are using this click object
			for s = 0 to Unit.CurrentMax
				if s <> n and Unit( s ).Active > 1
					if Unit( s ).CurrentMaxPath > -1
						for r = 0 to Unit( s ).CurrentMaxPath
							if UnitPath( s , r , 0 ).ClickObjID > -1
								if UnitPath( s , r , 0 ).ClickObjID = UnitPath( n , 0 , 0 ).ClickObjID then exit
							endif
						next r
						if r < Unit( s ).CurrentMaxPath + 1 then exit
					endif
				endif
			next s
			
			rem if none other was found, destroy
			if s = Unit.CurrentMax + 1
				DestroyClickObj( UnitPath( n , 0 , 0 ).ClickObjID )
			endif

		endif
		
		rem shift array stack down so next path can be walked
		Unit( n ).CurrentWaypoint = 1
		dec Unit( n ).CurrentMaxPath
		for sx = 0 to Unit( n ).CurrentMaxPath
			for sy = 0 to UnitPath( n , sx , 0 ).CurrentMaxWaypoint
				UnitPath( n , sx , sy ) = UnitPath( n , sx + 1 , sy )
			next sy
		next sx
		
		rem create new click object if required
		if UnitPath( n , 0 , 0 ).ClickObjID > -1
			
			rem check if any other units are using this click object
			for s = 0 to Unit.CurrentMax
				if s <> n and Unit( s ).Active > 1
					if Unit( s ).CurrentMaxPath > -1
						for r = 0 to Unit( s ).CurrentMaxPath
							if UnitPath( s , r , 0 ).ClickObjID > -1
								if UnitPath( s , r , 0 ).ClickObjID = UnitPath( n , 0 , 0 ).ClickObjID then exit
							endif
						next r
						if r < Unit( s ).CurrentMaxPath + 1 then exit
					endif
				endif
			next s
			
			rem if it is being used, force creation of new one and overwrite current ID
			if s < Unit.CurrentMax + 1
				UnitPath( n , 0 , 0 ).ClickObjID = CreateClickObj( ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).pos.x# , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).pos.y# , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).pos.z# , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Color , 0 , 1 )
			endif

		endif
		
		rem update next connection so it binds to the player instead of the waypoint
		if Unit( n ).CurrentMaxPath > 0
			if UnitPath( n , 0 , 0 ).ClickObjID > -1
				DestroyClickObjConnection( UnitPath( n , 0 , 0 ).ClickObjID )
				CreateClickObjConnection( UnitPath( n , 0 , 0 ).ClickObjID , Unit( n ).Obj , ClickObj( UnitPath( n , 0 , 0 ).ClickObjID ).Obj )
				if Unit( n ).Selected < 2 then HideClickObjConnection( UnitPath( n , 0 , 0 ).ClickObjID )
			endif
		endif
		
		rem hide connections if second last waypoint has been reached
		if Unit( n ).CurrentMaxPath = 0 and Unit( n ).Selected > 1
			if UnitPath( n , 0 , 0 ).ClickObjID > -1
				HideUnitPath( n )
			endif
		endif
		
		rem if path is finished, reset path
		if Unit( n ).CurrentMaxPath = -1
			ResetUnitPath( n )
			Unit( n ).AttackActive = 0
			Unit( n ).Ability.Active = -1
		endif
		
	endif
	
endfunction

function _Unit_Draw_Path( n )
	
	rem draw path (Debug)
	if Unit.DrawPath = 1
		for p = 0 to Unit( n ).CurrentMaxPath
			for w = 1 to UnitPath( n , p , 0 ).CurrentMaxWaypoint
				if SC_RayCastGroup( COL_TERRAIN , UnitPath( n , p , w ).pos.x# , 200 , UnitPath( n , p , w ).pos.z# , UnitPath( n , p , w ).pos.x# , -200 , UnitPath( n , p , w ).pos.z# , 0 )
					position object 1000 , UnitPath( n , p , w ).pos.x# , SC_GetStaticCollisionY() , UnitPath( n , p , w ).pos.z#
				endif
				x = object screen x( 1000 )
				y = object screen y( 1000 )
				a2fillcircle x , y , 3 , 0xFFFF0000
				if SC_RayCastGroup( COL_TERRAIN , UnitPath( n , p , w-1 ).pos.x# , 200 , UnitPath( n , p , w-1 ).pos.z# , UnitPath( n , p , w-1 ).pos.x# , -200 , UnitPath( n , p , w-1 ).pos.z# , 0 )
					position object 1000 , UnitPath( n , p , w-1 ).pos.x# , SC_GetStaticCollisionY() , UnitPath( n , p , w-1 ).pos.z#
				endif
				x2 = object screen x( 1000 )
				y2 = object screen y( 1000 )
				a2fillcircle x2 , y2 , 3 , 0xFFFF0000
				a2line x , y , x2 , y2 , 0xFFFF8000
			next w
		next p
	endif
				
endfunction

function _Pathfinder_Find_Free_Surrounding( sx , sy )
	
	remstart
	----------------------------------------------------------
	2 5 8
	1 4 7
	0 3 6
	----------------------------------------------------------
	remend
	
	rem pathfinder is not set up
	if World.PathFinder.ID = -1 then exitfunction

	rem local variables
	local x as integer
	local y as integer
	local nx as integer
	local ny as integer
	local count as integer
	
	rem find free surrounding
	count = -1
	for x = -1 to 1
		for y = -1 to 1
			nx = sx + x
			ny = sy + y
			if nx > -1 and nx < World.PathFinder.ResolutionX+1
				if ny > -1 and ny < World.PathFinder.ResolutionY+1
					if iaa_get pathmap value( World.PathFinder.ID , nx , ny ) = 0
						Misc.Pos2D.x = nx
						Misc.Pos2D.y = ny
						exitfunction 1
					endif
				endif
			endif
		next y
	next x
	
endfunction 0

function _ResizeArray_UnitPath( rs1 , rs2 , rs3 )
	
	rem local variables
	local x as integer
	local y as integer
	local z as integer

	rem copy data
	undim ResizeArray()
	dim ResizeArray( rs1 , rs2 , rs3 ) as PathfinderAAAT
	for x = 0 to Unit.CurrentMax
		for y = 0 to Unit.CurrentPathMax
			for z = 0 to Unit.CurrentWaypointMax
				ResizeArray( x , y , z ).pos.x# = UnitPath( x , y , z ).pos.x#
				ResizeArray( x , y , z ).pos.y# = UnitPath( x , y , z ).pos.y#
				ResizeArray( x , y , z ).pos.z# = UnitPath( x , y , z ).pos.z#
				ResizeArray( x , y , z ).CurrentMaxWaypoint = UnitPath( x , y , z ).CurrentMaxWaypoint
				ResizeArray( x , y , z ).ClickObjID = UnitPath( x , y , z ).ClickObjID
			next z
		next y
	next x
				
	rem resize array
	undim UnitPath()
	dim UnitPath( rs1 , rs2 , rs3 ) as PathfinderAAAT
	
	rem copy data back
	for x = 0 to Unit.CurrentMax
		for y = 0 to Unit.CurrentPathMax
			for z = 0 to Unit.CurrentWaypointMax
				UnitPath( x , y , z ).pos.x# = ResizeArray( x , y , z ).pos.x#
				UnitPath( x , y , z ).pos.y# = ResizeArray( x , y , z ).pos.y#
				UnitPath( x , y , z ).pos.z# = ResizeArray( x , y , z ).pos.z#
				UnitPath( x , y , z ).CurrentMaxWaypoint = ResizeArray( x , y , z ).CurrentMaxWaypoint
				UnitPath( x , y , z ).ClickObjID = ResizeArray( x , y , z ).ClickObjID
			next z
		next y
	next x
	
	rem update counters
	Unit.CurrentMax = rs1
	Unit.CurrentPathMax = rs2
	Unit.CurrentWaypointMax = rs3
	
endfunction
rem ---------------------------------------------------------------------------
rem Unit animations
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem User defined types
rem ---------------------------------------------------------------------------

type AnimKeysVT
	mStart                           		as integer
	mEnd                             		as integer
	mSpeed#                          		as float
endtype

type AnimVT
	Idle                                   as AnimKeysVT
	Creep                                  as AnimKeysVT
	Walk                                   as AnimKeysVT
	Run                                    as AnimKeysVT
	TakeOffJump                            as AnimKeysVT
	TakeOffFlyUp                           as AnimKeysVT
	TakeOffArriveTop                       as AnimKeysVT
	FlyIdle                                as AnimKeysVT
	FlyIdleToFly                           as AnimKeysVT
	Fly                                    as AnimKeysVT
	FlyToFlyIdle                           as AnimKeysVT
	LandPrepare                            as AnimKeysVT
	LandFlyDown                            as AnimKeysVT
	LandArriveBottom                       as AnimKeysVT
	GroundDie1                             as AnimKeysVT
	GroundDie2                             as AnimKeysVT
	GroundDieBurn                          as AnimKeysVT
	UnicornGroundMagicAttackPrepare1       as AnimKeysVT
	UnicornGroundMagicAttackPrepare2       as AnimKeysVT
	UnicornGroundMagicAttackPrepare3       as AnimKeysVT
	UnicornGroundMagicAttackRelease1       as AnimKeysVT
	UnicornGroundMagicAttackRelease2       as AnimKeysVT
	UnicornGroundMagicAttackRelease3       as AnimKeysVT
	ChangelingGroundMeleeAttackPrepare1    as AnimKeysVT
	ChangelingGroundMeleeAttackPrepare2    as AnimKeysVT
	ChangelingGroundMeleeAttackPrepare3    as AnimKeysVT
	ChangelingGroundMeleeAttackRelease1    as AnimKeysVT
	ChangelingGroundMeleeAttackRelease2    as AnimKeysVT
	ChangelingGroundMeleeAttackRelease3    as AnimKeysVT
endtype

rem ---------------------------------------------------------------------------
rem Unit Abilities
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem different abilities
#constant MaxUnitAbility                             8
#constant UNITABILITY_FLY                            0
#constant UNITABILITY_LAND                           1
#constant UNITABILITY_MAGIC_MISSILE                  2
#constant UNITABILITY_MOVE                           3
#constant UNITABILITY_STOP                           4
#constant UNITABILITY_HOLD                           5
#constant UNITABILITY_PATROL                         6
#constant UNITABILITY_TELEPORT                       7
#constant UNITABILITY_CHANGELING_MELEE_ATTACK        8

rem ---------------------------------------------------------------------------
rem User defined types
rem ---------------------------------------------------------------------------

type UnitAbilityVT
	AllowLeftMouseClickForPath       			as integer
	UsingFirstTime                   			as integer
endtype

type UnitAbilityAT
	Automatic                        			as integer
	Active                           			as integer
	Destination                      			as vec3
endtype

type UnitAbilityAAT
	Active                           			as integer
	LockButton                       			as integer
	BindButton                       			as integer
	Range#                           			as float
	HealthDamage#                    			as float
	ManaDamage#                      			as float
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitUnitAbility()
	
	rem ---------------------------------------------------------------------------
	rem Global arrays
	rem ---------------------------------------------------------------------------

	global dim UnitAbility() 						as UnitAbilityAAT
	
endfunction

function UnitAddAbility( n , ability , ButtonID )
	
	rem local variables
	local g as integer
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitAddAbility " + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem find button index
	for g = 0 to GUI.CurrentMax
		if GUI( g ).ID = ButtonID
			if GUI( g ).Active = 3 or GUI( g ).Active = 4
				exit
			endif
		endif
	next g
	
	rem not found - just log in console
	if g = GUI.CurrentMax + 1
		if Unit.logging = 1 or GUI.logging = 1 then AddTextToConsole( "ButtonID not found" , 0xFFFFFF00 , 3 )
		exitfunction n
	endif
	
	rem activate ability in ability list and bind to button
	UnitAbility( n , ability ).Active = 1
	UnitAbility( n , ability ).BindButton = g
	
	rem teleport ability requires a teleport object
	if ability = UNITABILITY_TELEPORT
		
		rem prepare clone
		Unit( n ).TeleportObj = find free object()
		make mesh from object 1 , Unit( n ).Obj
		make memblock from mesh 1 , 1
		delete mesh 1
		make mesh from memblock 1 , 1
		delete memblock 1
		make object Unit( n ).TeleportObj , 1 , 0
		delete mesh 1
		ConvertObjectFVFTo338( Unit( n ).TeleportObj )
		SetObjectDiffuse( Unit( n ).TeleportObj , 0xFFFFFFFF )
		set object transparency Unit( n ).TeleportObj , 1
		hide object Unit( n ).TeleportObj
		
	endif
	
endfunction n

function UnitSetAbilityRange( n , ability , range# )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitSetAbilityRange " + str$(n) + "," + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem set ability range
	UnitAbility( n , ability ).Range# = range#
	
endfunction n

function UnitLockAbility( n , ability )

	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitLockButton " + str$(n) + "," + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem lock button for unit
	UnitAbility( n , ability ).LockButton = 1
	
endfunction n

function UnitUnlockAbility( n , ability )
	
	rem local variables
	local g as integer
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitLockButton " + str$(n) + "," + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem lock button for unit
	UnitAbility( n , ability ).LockButton = 0
	
endfunction n

function UnitSetAbilityGlobal( n , ability )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitSetAbilityGlogal " + str$(n) + "," + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if ability has been added to this unit
	if UnitAbility( n , ability ).Active = 0
		if Unit.logging = 1 then AddTextToConsole( "Ability has not bee added!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem set ability global
	UnitAbility( n , ability ).Active = 2
	
endfunction n

function UnitSetAbilityLocal( n , ability )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitSetAbilityLocal " + str$(n) + "," + str$(ability) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem make sure ability has been added to this unit
	if UnitAbility( n , ability ).Active = 0
		if Unit.logging = 1 then AddTextToConsole( "Ability has not been added!" , 0xFFFF0000 ,3)
		exitfunction -1
	endif
	
	rem make ability local
	UnitAbility( n , ability ).Active = 1
	
endfunction n

function UnitUseAbility( n , ability , x# , z# )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitUseAbility " + str$(n) + "," + str$(ability) + "," + str$(x#) + "," + str$(z#) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem activate ability
	Unit.Ability.AllowLeftMouseClickForPath = 0
	Unit.ForceButtonClick = UnitAbility( n , ability ).BindButton
	Unit.ForceMouseClick = 1
	_Unit_Activate_Any_Abilities( n )
	
	rem right click to move unit or left click if default attack button was clicked
	if Unit.Ability.AllowLeftMouseClickForPath = 1
		
		rem formation must be recalculated
		_Unit_Calculate_Formation_Groups()

		rem reset path
		ResetUnitPath( n )
		
		rem reset follow flag
		if Unit( n ).Ability.Active = UNITABILITY_MOVE then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_STOP then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_HOLD then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_FLY then Unit( n ).FollowUnit = -1
		if Unit( n ).Ability.Active = UNITABILITY_LAND then Unit( n ).FollowUnit = -1
		if Mouse.Click = 4 then Unit( n ).FollowUnit = -1
		
		rem find paths
		if Unit( n ).CurrentMaxPath = -1
			UnitCalculatePath( n , Unit( n ).pos.x# , Unit( n ).pos.z# , x# , z# )
		else
			UnitCalculatepath( n , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.x# , UnitPath( n , Unit( n ).CurrentMaxPath , UnitPath( n , Unit( n ).CurrentMaxPath , 0 ).CurrentMaxWaypoint ).pos.z# , x# , z# )
		endif

	endif
	
	rem reset forces
	Unit.ForceButtonClick = -1
	Unit.ForceMouseClick = 0
	
endfunction n

function _Unit_Activate_Any_Abilities( n )
	
	rem fly ability
	if UnitAbility( n , UNITABILITY_FLY ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_FLY ).BindButton = Unit.ForceButtonClick
		
		rem global
		if UnitAbility( n , UNITABILITY_FLY ).Active = 2
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			
			rem player is flying
			Unit( n ).Ability.Active = UNITABILITY_FLY
			Unit( n ).AttackActive = 0
			Unit( n ).Active = 3
			
			rem handle button locks
			UnitAbility( n , UNITABILITY_FLY ).LockButton = 1
			UnitAbility( n , UNITABILITY_LAND ).LockButton = 1
			
		rem local
		else
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			if Unit.Ability.UsingFirstTime = 1
				if Unit.ForceButtonClick = -1 then Button.Clicked = -1
				
				rem player is flying
				Unit( n ).Ability.Active = UNITABILITY_FLY
				Unit( n ).AttackActive = 0
				Unit( n ).Active = 3

				rem handle button locks
				UnitAbility( n , UNITABILITY_FLY ).LockButton = 1
				UnitAbility( n , UNITABILITY_LAND ).LockButton = 1
		
			endif
		endif
		
	endif
	
	rem land ability
	if UnitAbility( n , UNITABILITY_LAND ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_LAND ).BindButton = Unit.ForceButtonClick
		
		rem global
		if UnitAbility( n , UNITABILITY_LAND ).Active = 2
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			
			rem player is landing
			Unit( n ).Ability.Active = UNITABILITY_LAND
			Unit( n ).AttackActive = 0
			Unit( n ).Active = 8
			
			rem handle button locks
			UnitAbility( n , UNITABILITY_FLY ).LockButton = 1
			UnitAbility( n , UNITABILITY_LAND ).LockButton = 1
			
		rem local
		else
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			if Unit.Ability.UsingFirstTime = 1
				if Unit.ForceButtonClick = -1 then Button.Clicked = -1
				
				rem player is landing
				Unit( n ).Ability.Active = UNITABILITY_LAND
				Unit( n ).AttackActive = 0
				Unit( n ).Active = 8
				
				rem handle button locks
				UnitAbility( n , UNITABILITY_FLY ).LockButton = 1
				UnitAbility( n , UNITABILITY_LAND ).LockButton = 1
		
			endif
		endif
		
	endif
	
	rem move ability
	if UnitAbility( n , UNITABILITY_MOVE ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_MOVE ).BindButton = Unit.ForceButtonClick

		rem reset button clicked in post
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem formation groups must be recalculated
			_Unit_Calculate_Formation_Groups()
			
			rem global
			if UnitAbility( n , UNITABILITY_MOVE ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem player is moving
				Unit( n ).Ability.Active = UNITABILITY_MOVE
				Unit( n ).AttackActive = 0
				Unit.Ability.AllowLeftMouseClickForPath = 1
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem player is moving
					Unit( n ).Ability.Active = UNITABILITY_MOVE
					Unit( n ).AttackActive = 0
					Unit.Ability.AllowLeftMouseClickForPath = 1
			
				endif
			endif

		endif
		
	endif
	
	rem stop ability
	if UnitAbility( n , UNITABILITY_STOP ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_STOP ).BindButton = Unit.ForceButtonClick
		
		rem formation groups must be recalculated
		_Unit_Calculate_Formation_Groups()
		
		rem global
		if UnitAbility( n , UNITABILITY_STOP ).Active = 2
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			
			rem player is stopping
			Unit( n ).Ability.Active = -1
			Unit( n ).AttackActive = 0
			ResetUnitPath( n )
			
		rem local
		else
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			if Unit.Ability.UsingFirstTime = 1
				if Unit.ForceButtonClick = -1 then Button.Clicked = -1
				
				rem player is stopping
				Unit( n ).Ability.Active = -1
				Unit( n ).AttackActive = 0
				ResetUnitPath( n )
		
			endif
		endif

	endif
	
	rem hold ability
	if UnitAbility( n , UNITABILITY_HOLD ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_HOLD ).BindButton = Unit.ForceButtonClick
		
		rem formation groups must be recalculated
		_Unit_Calculate_Formation_Groups()
		
		rem global
		if UnitAbility( n , UNITABILITY_HOLD ).Active = 2
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			
			rem player is holding
			Unit( n ).Ability.Active = UNITABILITY_HOLD
			Unit( n ).AttackActive = 0
			ResetUnitPath( n )
			
		rem local
		else
			if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
			if Unit.Ability.UsingFirstTime = 1
				if Unit.ForceButtonClick = -1 then Button.Clicked = -1
				
				rem player is holding
				Unit( n ).Ability.Active = UNITABILITY_HOLD
				Unit( n ).AttackActive = 0
				ResetUnitPath( n )
		
			endif
		endif

	endif
	
	rem patrol ability
	if UnitAbility( n , UNITABILITY_PATROL ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_PATROL ).BindButton = Unit.ForceButtonClick
		
		rem reset button clicked
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem formation groups must be recalculated
			_Unit_Calculate_Formation_Groups()
			
			rem global
			if UnitAbility( n , UNITABILITY_PATROL ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem player is patrolling
				Unit( n ).Ability.Active = UNITABILITY_PATROL
				Unit( n ).AttackActive = 1
				Unit.Ability.AllowLeftMouseClickForPath = 1
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem player is patrolling
					Unit( n ).Ability.Active = UNITABILITY_PATROL
					Unit( n ).AttackActive = 1
					Unit.Ability.AllowLeftMouseClickForPath = 1
			
				endif
			endif

		endif
		
	endif
	
	rem magic missile
	if UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).BindButton = Button.Clicked or UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).BindButton = Unit.ForceButtonClick
		
		rem reset button clicked
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem formation groups must be recalculated
			_Unit_Calculate_Formation_Groups()
			
			rem global
			if UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem player is attacking
				Unit( n ).Ability.Active = UNITABILITY_MAGIC_MISSILE
				Unit( n ).AttackActive = 1
				Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
				Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
				Unit.Ability.AllowLeftMouseClickForPath = 1
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem player is attacking
					Unit( n ).Ability.Active = UNITABILITY_MAGIC_MISSILE
					Unit( n ).AttackActive = 1
					Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
					Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
					Unit.Ability.AllowLeftMouseClickForPath = 1
			
				endif
			endif

		endif
		
	endif
	
	rem teleport ability
	if UnitAbility( n , UNITABILITY_TELEPORT ).BindButton = Button.Clicked or UnitAbility( n  , UNITABILITY_TELEPORT ).BindButton = Unit.ForceButtonClick
		
		rem activate ability
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem formation groups must be recalculated
			_Unit_Calculate_Formation_Groups()
			
			rem global
			if UnitAbility( n , UNITABILITY_TELEPORT ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem player is teleporting
				Unit( n ).Ability.Active = UNITABILITY_TELEPORT
				Unit( n ).AttackActive = 0
				Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
				Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
				Unit.Ability.AllowLeftMouseClickForPath = 1
				Unit( n ).Active = 19
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem player is teleporting
					Unit( n ).Ability.Active = UNITABILITY_TELEPORT
					Unit( n ).AttackActive = 0
					Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
					Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
					Unit.Ability.AllowLeftMouseClickForPath = 1
					Unit( n ).Active = 19
			
				endif
			endif

		endif
		
	endif
	
	rem changeling melee ability
	if UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).BindButton = Button.Clicked or UnitAbility( n  , UNITABILITY_CHANGELING_MELEE_ATTACK ).BindButton = Unit.ForceButtonClick
		
		rem activate ability
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem formation groups must be recalculated
			_Unit_Calculate_Formation_Groups()
			
			rem global
			if UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem unit is attacking
				Unit( n ).Ability.Active = UNITABILITY_CHANGELING_MELEE_ATTACK
				Unit( n ).AttackActive = 1
				Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
				Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
				Unit.Ability.AllowLeftMouseClickForPath = 1
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem unit is attacking
					Unit( n ).Ability.Active = UNITABILITY_CHANGELING_MELEE_ATTACK
					Unit( n ).AttackActive = 1
					Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
					Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
					Unit.Ability.AllowLeftMouseClickForPath = 1
			
				endif
			endif

		endif
		
	endif
	
	remstart
	template for new abilities
	-------------------------------------------------------------
	
	rem ? ability
	if UnitAbility( n , _ability_ ).BindButton = Button.Clicked or UnitAbility( n  , _ability_ ).BindButton = Unit.ForceButtonClick
		
		rem activate ability
		if Mouse.Click = 1 and GUI.MouseClickInvalid = 0 or Unit.ForceMouseClick = 1
			
			rem global
			if UnitAbility( n , _ability_ ).Active = 2
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				
				rem unit is ?
				Unit( n ).Ability.Active = _ability_
				Unit( n ).AttackActive = 0
				Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
				Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
				Unit.Ability.AllowLeftMouseClickForPath = 1
				Unit( n ).Active = 
				
			rem local
			else
				if Unit.ForceButtonClick = -1 then Unit.PostResetButtonClicked = 1
				if Unit.Ability.UsingFirstTime = 1
					if Unit.ForceButtonClick = -1 then Button.Clicked = -1
					
					rem unit is ?
					Unit( n ).Ability.Active = _ability_
					Unit( n ).AttackActive = 0
					Unit( n ).Ability.Destination.x# = Mouse.Click3D.x#
					Unit( n ).Ability.Destination.z# = Mouse.Click3D.z#
					Unit.Ability.AllowLeftMouseClickForPath = 1
					Unit( n ).Active = 
			
				endif
			endif

		endif
		
	endif
	
	-------------------------------------------------------------
	remend
				
endfunction

function _Unit_Handle_Active_Abilities( n )
	
	rem local variables
	local success as integer
	local dist# as float
	local r as integer
	
	remstart check if unit has an automatic attack
	if Unit( n ).Ability.Automatic = Unit( n ).Ability.Active

		rem check if enemy unit is in ability range
		success = 0
		for r = 0 to Unit.CurrentMax
			if Unit( r ).Active > 1
				if Unit( r ).Control <> Unit( n ).Control and Unit( n ).Control <> UNITCONTROL_NOONE
					dist# = (Unit( r ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( r ).pos.z# - Unit( n ).pos.z#)^2
					
					rem in range
					if dist# < UnitAbility( n , Unit( n ).Ability.Automatic ).Range#^2
						
						rem activate ability
						if Unit( n ).Ability.Automatic = UNITABILITY_MAGIC_MISSILE
							if Unit( n ).Active < 13 or Unit( n ).Active > 15 then Unit( n ).Active = 13
							if Unit( n ).FollowUnit = -1 then Unit( n ).FollowUnit = r
							Unit( n ).AttackActive = 1
						endif
						
						rem activate ability
						if Unit( n ).Ability.Automatic = UNITABILITY_CHANGELING_MELEE_ATTACK
							if Unit( n ).Active < 
						
					endif
					
				endif
			endif
		next r
		
	endif
	remend
	
	rem unit is using magic missile
	if Unit( n ).Ability.Active = UNITABILITY_MAGIC_MISSILE
		
		rem check if enemy unit is in ability range
		success = 0
		for r = 0 to Unit.CurrentMax
			if Unit( r ).Active > 1
				if Unit( r ).Control <> Unit( n ).Control and Unit( n ).Control <> UNITCONTROL_NOONE
					dist# = (Unit( r ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( r ).pos.z# - Unit( n ).pos.z#)^2
					
					rem in range
					if dist# < UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).Range#^2
						
						rem execute ability
						if Unit( n ).Active < 13 or Unit( n ).Active > 15 then Unit( n ).Active = 13
						if Unit( n ).FollowUnit = -1 then Unit( n ).FollowUnit = r
						Unit( n ).AttackActive = 1
					endif

				endif
			endif
		next r
		
		rem out of range
		if Unit( n ).FollowUnit > -1 and (Unit( n ).Active < 13 or Unit( n ).Active > 15)
			dist# = (Unit( Unit( n ).FollowUnit ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( Unit( n ).FollowUnit ).pos.z# - Unit( n ).pos.z#)^2
			if dist# > Unit( n ).GroundViewRange#^2
				Unit( n ).FollowUnit = -1
				Unit( n ).Ability.Active = -1
				Unit( n ).AttackActive = 0
			endif
		endif
		
	endif
	
	rem unit is using changeling melee
	if Unit( n ).Ability.Active = UNITABILITY_CHANGELING_MELEE_ATTACK
		
		rem check if enemy unit is in ability range
		success = 0
		for r = 0 to Unit.CurrentMax
			if Unit( r ).Active > 1
				if Unit( r ).Control <> Unit( n ).Control and Unit( n ).Control <> UNITCONTROL_NOONE
					dist# = (Unit( r ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( r ).pos.z# - Unit( n ).pos.z#)^2
					
					rem in range
					if dist# < UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).Range#^2
						
						rem execute ability
						if Unit( n ).Active < 20 or Unit( n ).Active > 22 then Unit( n ).Active = 20
						if Unit( n ).FollowUnit = -1 then Unit( n ).FollowUnit = r
						Unit( n ).AttackActive = 1

					endif

				endif
			endif
		next r
		
		rem out of range
		if Unit( n ).FollowUnit > -1 and (Unit( n ).Active < 20 or Unit( n ).Active > 22)
			dist# = (Unit( Unit( n ).FollowUnit ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( Unit( n ).FollowUnit ).pos.z# - Unit( n ).pos.z#)^2
			if dist# > Unit( n ).GroundViewRange#^2
				Unit( n ).FollowUnit = -1
				Unit( n ).Ability.Active = -1
				Unit( n ).AttackActive = 0
			endif
		endif
		
	endif
	
	rem handle following destroyed units
	if Unit( n ).FollowUnit > -1
		if Unit( Unit( n ).FollowUnit ).Active < 2
			Unit( n ).FollowUnit = -1
			Unit( n ).Active = 2
			if Unit( n ).Ability.Active <> Unit( n ).Ability.Automatic then UnitCalculatePath( n , Unit( n ).pos.x# , Unit( n ).pos.z# , Unit( n ).Ability.Destination.x# , Unit( n ).Ability.Destination.z# )
		endif
	endif
	
endfunction
rem ---------------------------------------------------------------------------
rem Unit - Controls all basic movements of units
rem ---------------------------------------------------------------------------

remstart
	AttackActive 			- 0 if a unit is walking a "green" path, i.e. unit will pass hostile units without attacking
								  1 if a unit is walking a "red" path, i.i. unit will attack any hostile units along the path
	FollowUnit				- Stores the ID of a unit to follow.
								  A value of -1 means it's not following anything
	
remend

rem ---------------------------------------------------------------------------
rem constants
rem ---------------------------------------------------------------------------

rem unit control
#constant UNITCONTROL_PLAYER        1
#constant UNITCONTROL_NOONE         2
#constant UNITCONTROL_ENEMY         3

rem ---------------------------------------------------------------------------
rem User defined types
rem ---------------------------------------------------------------------------

type UnitStatsVT
	HealthEnable                     as integer
	ManaEnable                       as integer
	ShieldEnable                     as integer
	
	MaxHealth                        as integer
	CurrentHealth#                   as float
	HealthRecoil#                    as float
	MaxMana                          as integer
	CurrentMana#                     as float
	ManaRecoil#                      as float
	MaxShield                        as integer
	CurrentShield#                   as float
	ShieldRecoil#                    as float
endtype

type UnitVT
	CurrentMax 								as integer
	CurrentPathMax  						as integer
	CurrentWaypointMax					as integer
	CurrentAnimationMax    				as integer
	CurrentAbilityMax 					as integer
	CurrentFormationMax    				as integer
	
	logging                          as integer
	DrawPath                         as integer
	DrawFormation							as integer
	LastLoaded                       as integer
	Ability                          as UnitAbilityVT
	
	PostResetButtonClicked           as integer
	DisableUnitDeselect              as integer
	
	ForceButtonClick                 as integer
	ForceMouseClick                  as integer
	
	FormationCount                   as integer
endtype

type UnitAT
	Active                           as integer
	Control                          as integer
	
	pos                              as vec3
	oldpos                           as vec3
	angle                            as vec3
	GroundSpeed#                     as float
	AirSpeed#                        as float
	Size#                            as float
	HeightOffset#                    as float
	CurrentSpeed#                    as float
	
	GroundViewRange#                 as float
	AirViewRange#                    as float
	
	Obj                              as word
	HalfSelectObj                    as word
	SelectObj                        as word
	TeleportObj                      as word
	Filename$                        as string
	DiffuseImg                       as word
	NormalImg                        as word
	BumpImg                          as word
	
	Selected                         as integer
	CurrentWaypoint                  as integer
	CurrentMaxPath                   as integer
	WasSelected                      as integer
	FollowUnit                       as integer
	FollowUnitDelayTimer             as integer
	WasSetToFollowUnit               as integer
	AttackActive              			as integer
	EvadeUnit                        as integer
	EvadeUnitTimer                   as integer
	EvadeAngle#                      as float
	
	UseFormation                   	as integer
	FormationPos							as vec3
	
	SpellCastLimb                    as integer
	
	Stats                            as UnitStatsVT
	Ability                          as UnitAbilityAT
	Anim                             as AnimVT
	RandomValue                      as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitUnit()
	
	rem debug
	DebugOutput( 0 , "Initialising Units" )
	
	rem ---------------------------------------------------------------------------
	rem Global Variables
	rem ---------------------------------------------------------------------------
	
	global Unit                      			as UnitVT
	
	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------
	
	global dim Unit()      							as UnitAT

	rem initial values
	Unit.CurrentMax = -1
	Unit.CurrentPathMax = 1
	Unit.CurrentWaypointMax = 1
	Unit.CurrentAbilityMax = -1
	Unit.CurrentFormationMax = -1
	Unit.ForceButtonClick = -1
	Unit.ForceMouseClick = 0
	
	rem Initialise further components
	InitUnitFormation()
	InitUnitPath()
	InitUnitAbility()
	
endfunction

function CreateUnit( Filename$ , x# , y# , z# , control )
	
	rem local variables
	local n as integer
	local r as integer
	local color as dword
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "CreateUnit " + chr$(34) + Filename$ + chr$(34) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) + "," + str$(typ) , 0xFF00FFFF , 0 )
	
	rem find a free slot with an inactive unit of the same file
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Filename$ = Filename$ and Unit( n ).Active < 2 then exit
	next n
	
	rem find free slot
	if n = Unit.CurrentMax + 1
		for n = 0 to Unit.CurrentMax
			if Unit( n ).Active < 2 then exit
		next n
	endif
	
	rem no free slot, create
	if n = Unit.CurrentMax + 1
		
		rem expand unit array
		array insert at bottom Unit()
		
		rem expand other arrays
		dim UnitAbility( Unit.CurrentMax+1 , MaxUnitAbility ) as UnitAbilityAAT
		_ResizeArray_UnitPath( Unit.CurrentMax+1 , Unit.CurrentPathMax , Unit.CurrentWaypointMax )
	endif
	
	rem load the unit
	if Unit( n ).Filename$ <> Filename$
		if Unit( n ).Obj > 0
			if object exist( Unit( n ).Obj )
				delete object Unit( n ).Obj
			endif
		endif
		if Unit( n ).TeleportObj > 0
			if object exist( Unit( n ).TeleportObj )
				delete object Unit( n ).TeleportObj
			endif
			Unit( n ).TeleportObj = 0
		endif
		
		rem load the object
		Unit( n ).Obj = find free object()
		load object Filename$ , Unit( n ).Obj
	endif
	
	rem calculate size of unit
	size# = (object size x(Unit( n ).Obj) + object size z(Unit( n ).Obj)) * 50
	
	rem choose colour of selection rings
	if control = UNITCONTROL_PLAYER then img = IMGUnitSelectFriendly
	if control = UNITCONTROL_NOONE then img = IMGUnitSelectNeutral
	if control = UNITCONTROL_ENEMY then img = IMGUnitSelectHostile
	
	rem check if unit needs to load anything
	if Unit( n ).Active = 0
		
		rem load unit half selection ring
		Unit( n ).HalfSelectObj = find free object()
		load object "media\objects\unitselect\halfselected.x" , Unit( n ).HalfSelectObj
		scale object Unit( n ).HalfSelectObj , size# , size# , size#
		set object transparency Unit( n ).HalfSelectObj , 1
		set object light Unit( n ).HalfSelectObj , 0
		hide object Unit( n ).HalfSelectObj
		
		rem load unit selection ring
		Unit( n ).SelectObj = find free object()
		load object "media\objects\unitselect\selected.x" , Unit( n ).SelectObj
		scale object Unit( n ).SelectObj , size# , size# , size#
		set object transparency Unit( n ).SelectObj , 1
		set object light Unit( n ).SelectObj , 0
		set object cull Unit( n ).SelectObj , 0
		hide object Unit( n ).SelectObj
	endif

	rem properties
	show object Unit( n ).Obj
	position object Unit( n ).Obj , x# , y# , z#
	texture object Unit( n ).HalfSelectObj , img
	texture object Unit( n ).SelectObj , img
	
	rem set parameters
	Unit( n ).Filename$ = Filename$
	Unit( n ).Active = 2
	Unit( n ).Control = control
	Unit( n ).pos.x# = x#
	Unit( n ).pos.y# = y#
	Unit( n ).pos.z# = z#
	Unit( n ).GroundSpeed# = 0.3
	Unit( n ).CurrentMaxPath = -1
	Unit( n ).Size# = size# / 100
	Unit( n ).HeightOffset# = 0
	Unit( n ).SpellCastLimb = 0
	Unit( n ).WasSelected = 0
	Unit( n ).FollowUnit = -1
	Unit( n ).WasSetToFollowUnit = -1
	Unit( n ).AttackActive = 0
	Unit( n ).Ability.Automatic = -1
	Unit( n ).Ability.Active = -1
	Unit( n ).TeleportObj = 0
	Unit( n ).UseFormation = -1
	Unit.LastLoaded = n
	
	rem to avoid division by 0
	Unit( n ).Stats.MaxHealth = 1
	Unit( n ).Stats.MaxMana = 1
	Unit( n ).Stats.MaxShield = 1
	
	rem reset ability list
	for r = 0 to MaxUnitAbility
		UnitAbility( n , r ).Active = 0
		UnitAbility( n , r ).LockButton = 0
		UnitAbility( n , r ).BindButton = -2
	next r
	
	rem initial ability ranges
	UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).Range# = 8.0
	UnitAbility( n , UNITABILITY_TELEPORT ).Range# = 7.5
	UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).Range# = Unit( n ).size#
	
	rem initial ability damage values
	UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).HealthDamage# = 8.0
	UnitAbility( n , UNITABILITY_MAGIC_MISSILE ).ManaDamage# = 0
	UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).HealthDamage# = 5.0
	UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).ManaDamage# = 0
	
endfunction n

function UnitAddParallaxMapping( n , Diffuse$ , Normal$ , Bump$ )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitAddParallaxMapping " + str$(n) + "," + Diffuse$ + "," + Normal$ + "," + Bump$ , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem check if files exist
	if file exist( Diffuse$ ) = 0
		if Unit.logging = 1 then AddTextToConsole( "File does not exist! " + Diffuse$ , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	if file exist( Normal$ ) = 0
		if Unit.logging = 1 then AddTextToConsole( "File does not exist!" + Normal$ , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	if file exist( Bump$ ) = 0
		if Unit.logging = 1 then AddTextToConsole( "File does not exist!" + Bump$ , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem load files
	Unit( n ).DiffuseImg = find free image()
	LoadImage( Diffuse$ , Unit( n ).DiffuseImg )
	Unit( n ).NormalImg = find free image()
	LoadImage( Normal$ , Unit( n ).NormalImg )
	Unit( n ).BumpImg = find free image()
	LoadImage( Bump$ , Unit( n ).BumpImg )
	
	rem texture object
	texture object Unit( n ).Obj , 0 , Unit( n ).DiffuseImg
	texture object Unit( n ).Obj , 1 , Unit( n ).NormalImg
	texture object Unit( n ).Obj , 2 , Unit( n ).BumpImg
	
	rem apply effect
	set object effect Unit( n ).Obj , ParallaxMappingFX
	
	rem same for teleport object
	if Unit( n ).TeleportObj > 0
		texture object Unit( n ).TeleportObj , Unit( n ).DiffuseImg
	endif
	
endfunction n

function UnitPosition( n , x# , y# , z# )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitPosition " + str$(n) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem position
	Unit( n ).pos.x# = x#
	Unit( n ).pos.y# = y#
	Unit( n ).pos.z# = z#
	Unit( n ).oldpos = Unit( n ).pos
	
endfunction n

function UnitScale( n , SizeX# , SizeY# , SizeZ# )

	rem logging
	if Unit.logging = 1 then AddTextToConsole( "UnitScale " + str$(SizeX#) + "," + str$(SizeY#) + "," + str$(SizeZ#) , 0xFF00FFFF , 0 )
	
	rem make sure unit is active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 0 )
		exitfunction -1
	endif
	
	rem calculate size of unit
	Unit( n ).Size# = Unit( n ).Size# * ((SizeX# + SizeY# + SizeZ#)/300.0)
	
	rem scale unit
	scale object Unit( n ).Obj , SizeX# , SizeY# , SizeZ#
	scale object Unit( n ).HalfSelectObj , Unit( n ).Size#*100 , Unit( n ).Size#*100 , Unit( n ).Size#*100
	scale object Unit( n ).SelectObj , Unit( n ).Size#*100 , Unit( n ).Size#*100 , Unit( n ).Size#*100
	
endfunction n

function DestroyUnit( n )
	
	rem logging
	if Unit.logging = 1 then AddTextToConsole( "DestroyUnit " + str$(n) , 0xFFFFFFFF , 0 )
	
	rem check if active
	if Unit( n ).Active < 2
		if Unit.logging = 1 then AddTextToConsole( "Unit not active!" , 0xFFFF0000 , 3 )
		exitfunction -1
	endif
	
	rem destroy the unit
	hide object Unit( n ).Obj
	hide object Unit( n ).HalfSelectObj
	hide object Unit( n ).SelectObj
	Unit( n ).Active = 1
	Unit( n ).Selected = 0
	
	rem unbind any buttons
	for g = 0 to GUI.CurrentMax
		for b = 0 to GUIUnitBindMax
			if GUIBindUnit( g , b ) = n then GUIUnbindUnit( g , b )
		next b
	next g
	
	rem disable any abilities
	for g = 0 to MaxUnitAbility
		UnitAbility( n , g ).Active = 0
	next g
	
endfunction n

function ControlUnit()
	
	rem local variables
	local n as integer
	local sx as integer
	local sy as integer
	local success as integer
	local x# as float
	local y# as float
	local z# as float
	
	rem reset some values
	Unit.PostResetButtonClicked = 0
	Unit.DisableUnitDeselect = 0
	
	rem calculate formation groups on mouse click edge
	if Mouse.Click = 4 and shiftkey() = 0 then _Unit_Calculate_Formation_Groups()
	
	rem loop through all active units
	for n = 0 to Unit.CurrentMax
		
		rem reset some values
		Unit.Ability.AllowLeftMouseClickForPath = 0
		Unit.Ability.UsingFirstTime = 0
		
		rem check if unit is using an ability
		if Unit( n ).Active > 1 and Unit( n ).Control = UNITCONTROL_PLAYER

			rem check for button press
			if Button.Clicked > -1
				
				rem check if ability is being used for the first time
				if Unit( n ).Ability.Active = -1 then Unit.Ability.UsingFirstTime = 1
				Unit.DisableUnitDeselect = 1

			endif
		
			rem right-click disables any ability usage, as long as enemy units aren't being right-clicked
			if Mouse.click = 4 and Unit( n ).Selected > 1
				success = GetUnitUnderMouse()
				if success > -1
					if Unit( success ).Control = Unit( n ).Control then success = -1
				endif
				if success = -1
					Unit( n ).Ability.Active = -1
					Unit( n ).AttackActive = 0
				endif
			endif
		
		endif
		
		rem on ground units
		if Unit( n ).Active = 2
			
			rem unit is selected
			if Unit( n ).Selected > 1 and Unit( n ).Control = UNITCONTROL_PLAYER
				
				_Unit_Activate_Any_Abilities( n )
				_Unit_Create_Ground_Path_With_Mouse( n )
				_Unit_Draw_Path( n )

			endif
			
			rem unit is following another unit
			if Unit( n ).FollowUnit > -1
				
				_Unit_Handle_Ground_Following( n )
				
			endif

			_Unit_Handle_Active_Abilities( n )
			_Unit_Handle_Ground_Paths( n )
			_Unit_Handle_Ground_Animations( n )
			_Unit_Handle_Ground_Movement( n )
			
		endif
		
		rem stop moving unit
		if Unit( n ).Active = 3
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )

			rem animations
			_Unit_Handle_Ground_Animations( n )
			
			rem unit ground movements
			_Unit_Handle_Ground_Movement( n )
			
			rem next state
			if Unit( n ).CurrentSpeed# < Unit( n ).GroundSpeed# * 0.222 then Unit( n ).Active = 4
			
		endif
		
		rem take off from ground
		if Unit( n ).Active = 4

			rem play jump up
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.TakeOffJump.mStart , Unit( n ).Anim.TakeOffJump.mEnd , Unit( n ).Anim.TakeOffJump.mSpeed# )
			Unit( n ).Active = 5
			
		endif
		
		rem fly up from ground
		if Unit( n ).Active = 5
			
			rem increase offset to 5 if still in air
			if Unit( n ).HeightOffset# < 5.0 then inc Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
			if Unit( n ).HeightOffset# > 5.0 then Unit( n ).HeightOffset# = 5.0

			rem fly up animation
			if Unit( n ).HeightOffset# = 5.0
				PlayObject( Unit( n ).Obj , Unit( n ).Anim.TakeOffFlyUp.mStart , Unit( n ).Anim.TakeOffFlyUp.mEnd , Unit( n ).Anim.TakeOffFlyUp.mSpeed# )
				Unit( n ).Active = 6
			endif

		endif
		
		rem arrive at top
		if Unit( n ).Active = 6
			
			rem arrive at top
			if ObjectPlaying( Unit( n ).Obj ) = 0
				PlayObject( Unit( n ).Obj , Unit( n ).Anim.TakeOffArriveTop.mStart , Unit( n ).Anim.TakeOffArriveTop.mEnd , Unit( n ).Anim.TakeOffArriveTop.mSpeed# )
				Unit( n ).Active = 7
				Unit( n ).Ability.Active = -1
				UnitAbility( n , UNITABILITY_LAND ).LockButton = 0
				_Unit_Calculate_Formation_Groups()
			endif

		endif
		
		rem flying 	
		if Unit( n ).Active = 7
				
			rem check if unit is selected
			if Unit( n ).Selected > 1 and Unit( n ).Control = UNITCONTROL_PLAYER
				
				_Unit_Create_Air_Path_With_Mouse( n )
				_Unit_Draw_Path( n )
				_Unit_Activate_Any_Abilities( n )
			
			endif
			
			_Unit_Handle_Air_Paths( n )
			_Unit_Handle_Air_Animations( n )
			_Unit_Handle_Air_Movement( n )
			
		endif
		
		rem slow down unit
		if Unit( n ).Active = 8
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
			
			rem increase offset to 5 if still in air
			if Unit( n ).HeightOffset# < 5 then inc Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
			if Unit( n ).HeightOffset# > 5 then Unit( n ).HeightOffset# = 5
			
			rem position at terrain height
			if SC_RayCastGroup( COL_TERRAIN , Unit( n ).pos.x# , 200 , Unit( n ).pos.z# , Unit( n ).pos.x# , -200 , Unit( n ).pos.z# , 0 )
				Unit( n ).pos.y# = curvevalue( SC_GetStaticCollisionY() , Unit( n ).pos.y# , 4.0 / TBM.delta# )
			else
				Unit( n ).pos.y# = curvevalue( 0 , Unit( n ).pos.y# , 4.0 / TBM.delta# )
			endif
			
			rem control animation
			if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.FlyIdle.mStart , Unit( n ).Anim.FlyIdle.mEnd , Unit( n ).Anim.FlyIdle.mSpeed# )

			rem next state
			if Unit( n ).CurrentSpeed# < 0.222 then Unit( n ).Active = 9
			
		endif
		
		rem initiate landing
		if Unit( n ).Active = 9
			
			rem play animation
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.LandPrepare.mStart , Unit( n ).Anim.LandPrepare.mEnd , Unit( n ).Anim.LandPrepare.mSpeed# )
			Unit( n ).Active = 10
			
		endif
		
		rem prepare to land
		if Unit( n ).Active = 10
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 2.0 / TBM.delta# )
			
			rem handle animation
			if ObjectPlaying( Unit( n ).Obj ) = 0
				PlayObject( Unit( n ).Obj , Unit( n ).Anim.LandFlyDown.mStart , Unit( n ).Anim.LandFlyDown.mEnd , Unit( n ).Anim.LandFlyDown.mSpeed# )
				Unit( n ).Active = 11
			endif
			
		endif
		
		rem descend
		if Unit( n ).Active = 11
			
			rem decrease offset to 0 if still in air
			if Unit( n ).HeightOffset# > 0.0 then dec Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
			if Unit( n ).HeightOffset# < 0.0 then Unit( n ).HeightOffset# = 0.0
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )

			rem handle animation
			if Unit( n ).HeightOffset# = 0.0
				PlayObject( Unit( n ).Obj , Unit( n ).Anim.LandArriveBottom.mStart , Unit( n ).Anim.LandArriveBottom.mEnd , Unit( n ).Anim.LandArriveBottom.mSpeed# )
				Unit( n ).Active = 12
			endif
		
		endif
		
		rem arrive on ground
		if Unit( n ).Active = 12
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 5.0 / TBM.delta# )
			
			rem decrease offset to 0 if still in air
			if Unit( n ).HeightOffset# > 0 then dec Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
			if Unit( n ).HeightOffset# < 0 then Unit( n ).HeightOffset# = 0

			rem handle animation
			if ObjectPlaying( Unit( n ).Obj ) = 0
				Unit( n ).Active = 2
				Unit( n ).Ability.Active = -1
				UnitAbility( n , UNITABILITY_FLY ).LockButton = 0
				_Unit_Calculate_Formation_Groups()
			endif
			
		endif
		
		rem initiate transition into attack
		if Unit( n ).Active = 13
			
			rem play animation
			Unit( n ).RandomValue = rnd(2)
			StopObject( Unit( n ).Obj )
			if Unit( n ).RandomValue = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackPrepare1.mStart , Unit( n ).Anim.UnicornGroundMagicAttackPrepare1.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackPrepare1.mSpeed# )
			if Unit( n ).RandomValue = 1 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackPrepare2.mStart , Unit( n ).Anim.UnicornGroundMagicAttackPrepare2.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackPrepare2.mSpeed# )
			if Unit( n ).RandomValue = 2 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackPrepare3.mStart , Unit( n ).Anim.UnicornGroundMagicAttackPrepare3.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackPrepare3.mSpeed# )
			
			rem next state
			Unit( n ).Active = 14
			
		endif
		
		rem transition into attack
		if Unit( n ).Active = 14
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 2.0 / TBM.delta# )
			
			rem rotate towards target
			if Unit( n ).FollowUnit > -1 then Unit( n ).angle.y# = curveangle( 270 - atanfull( Unit( n ).pos.z# - Unit( Unit( n ).FollowUnit ).pos.z# , Unit( n ).pos.x# - Unit( Unit( n ).FollowUnit ).pos.x# ) , Unit( n ).angle.y# , 1.0 / TBM.delta# )
			_Unit_Handle_Ground_Movement( n )
			
			rem handle animation
			if ObjectPlaying( Unit( n ).Obj ) = 0
				StopObject( Unit( n ).Obj )
				if Unit( n ).RandomValue = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackRelease1.mStart , Unit( n ).Anim.UnicornGroundMagicAttackRelease1.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackRelease1.mSpeed# )
				if Unit( n ).RandomValue = 1 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackRelease2.mStart , Unit( n ).Anim.UnicornGroundMagicAttackRelease2.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackRelease2.mSpeed# )
				if Unit( n ).RandomValue = 2 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.UnicornGroundMagicAttackRelease3.mStart , Unit( n ).Anim.UnicornGroundMagicAttackRelease3.mEnd , Unit( n ).Anim.UnicornGroundMagicAttackRelease3.mSpeed# )
				if Unit( n ).FollowUnit > -1 then CreateMagicMissile( n , limb position x( Unit( n ).Obj , Unit( n ).SpellCastLimb ) , limb position y( Unit( n ).Obj , Unit( n ).SpellCastLimb ) , limb position z( Unit( n ).Obj , Unit( n ).SpellCastLimb ) , Unit( n ).FollowUnit )
				Unit( n ).Active = 15
			endif
			
			rem player has the option to cancel attack
			rem if the player is clicking on an enemy, don't do this check
			if Mouse.click > 0 then success = GetUnitUnderMouse()
			if success > -1
				if Unit( success ).Control = Unit( n ).Control then success = -1
			endif
			if success = -1
				if Unit( n ).Selected > 1
					_Unit_Activate_Any_Abilities( n )
					_Unit_Create_Ground_Path_With_Mouse( n )
				endif
			endif
			
			rem break if ability changes
			if Unit( n ).Ability.Active <> UNITABILITY_MAGIC_MISSILE then Unit( n ).Active = 2
			
		endif
		
		rem wait for recoil animation to finish
		if Unit( n ).Active = 15
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 2.0 / TBM.delta# )
			
			rem rotate towards target
			if Unit( n ).FollowUnit > -1 then Unit( n ).angle.y# = curveangle( 270 - atanfull( Unit( n ).pos.z# - Unit( Unit( n ).FollowUnit ).pos.z# , Unit( n ).pos.x# - Unit( Unit( n ).FollowUnit ).pos.x# ) , Unit( n ).angle.y# , 1.0 / TBM.delta# )
			_Unit_Handle_Ground_Movement( n )
			
			rem return to idle state
			if ObjectPlaying( Unit( n ).Obj ) = 0
				Unit( n ).Active = 2
				
				rem if not automatic, disable again
				if Unit( n ).Ability.Automatic <> UNITABILITY_MAGIC_MISSILE
					Unit( n ).AttackActive = 0
					Unit( n ).Ability.Active = -1
					Unit( n ).FollowUnit = -1
					ResetUnitPath( n )
					UnitCalculatePath( n , Unit( n ).pos.x# , Unit( n ).pos.z# , Unit( n ).Ability.Destination.x# , Unit( n ).Ability.Destination.z# )
				endif
				
			endif
			
			rem player has the option to cancel attack
			rem if the player is clicking on an enemy, don't do this check
			if Mouse.click > 0 then success = GetUnitUnderMouse()
			if success > -1
				if Unit( success ).Control = Unit( n ).Control then success = -1
			endif
			if success = -1
				if Unit( n ).Selected > 1
					_Unit_Activate_Any_Abilities( n )
					_Unit_Create_Ground_Path_With_Mouse( n )
				endif
			endif
			
			rem break if ability changed
			if Unit( n ).Ability.Active <> UNITABILITY_MAGIC_MISSILE then Unit( n ).Active = 2
			
		endif
		
		rem kill unit
		if Unit( n ).Active = 16
			
			rem initiate animation
			Unit( n ).RandomValue = rnd(1)
			StopObject( Unit( n ).Obj )
			if Unit( n ).RandomValue = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.GroundDie1.mStart , Unit( n ).Anim.GroundDie1.mEnd , Unit( n ).Anim.GroundDie1.mSpeed# )
			if Unit( n ).RandomValue = 1 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.GroundDie2.mStart , Unit( n ).Anim.GroundDie2.mEnd , Unit( n ).Anim.GroundDie2.mSpeed# )
			
			rem next state
			Unit( n ).Active = 18
			
		endif
		
		rem burn, then kill unit
		if Unit( n ).Active = 17
			
			rem initiate animation
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.GroundDieBurn.mStart , Unit( n ).Anim.GroundDieBurn.mEnd , Unit( n ).Anim.GroundDieBurn.mSpeed# )
			
			rem next state
			Unit( n ).Active = 18
		
		endif
			
		rem unit is dead
		if Unit( n ).Active = 18
			
			rem if animation stops playing, destroy unit
			if ObjectPlaying( Unit( n ).Obj ) = 0 then DestroyUnit( n )
			
		endif
		
		rem teleport unit
		if Unit( n ).Active = 19
			
			rem check if destination exceeds teleportation distance limit
			if (Unit( n ).pos.x# - Unit( n ).Ability.Destination.x#)^2 + (Unit( n ).pos.z# - Unit( n ).Ability.Destination.z#)^2 > UnitAbility( n , UNITABILITY_TELEPORT ).Range#^2
				
				rem recalculate destination coordinates
				set vector3 1 , Unit( n ).Ability.Destination.x# - Unit( n ).pos.x# , 0 , Unit( n ).Ability.Destination.z# - Unit( n ).pos.z#
				normalize vector3 1 , 1
				scale vector3 1 , 1 , UnitAbility( n , UNITABILITY_TELEPORT ).Range#
				Unit( n ).Ability.Destination.x# = x vector3(1) + Unit( n ).pos.x#
				Unit( n ).Ability.Destination.z# = z vector3(1) + Unit( n ).pos.z#
				
			endif
			
			rem create teleport effect
			CreateTeleportEffect( n , Unit( n ).Size# , Unit( n ).pos.x# , Unit( n ).pos.y# , Unit( n ).pos.z# )
			
			rem position unit at destination
			Unit( n ).pos = Unit( n ).Ability.Destination
			
			rem return to idle
			Unit( n ).Active = 2
			
		endif
		
		rem changeling melee attack
		if Unit( n ).Active = 20
			
			rem initiate animation
			Unit( n ).RandomValue = rnd(2)
			StopObject( Unit( n ).Obj )
			if Unit( n ).RandomValue = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare1.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare1.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare1.mSpeed# )
			if Unit( n ).RandomValue = 1 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare2.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare2.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare2.mSpeed# )
			if Unit( n ).RandomValue = 2 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare3.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare3.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackPrepare3.mSpeed# )
		
			rem next state
			Unit( n ).Active = 21
			
		endif
		
		rem changeling melee attack was initiated
		if Unit( n ).Active = 21
			
			rem inflict damage to target unit
			if ObjectPlaying( Unit( n ).Obj ) = 0
				if Unit( n ).FollowUnit > -1 then DamageUnit( Unit( n ).FollowUnit , UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).HealthDamage# , UnitAbility( n , UNITABILITY_CHANGELING_MELEE_ATTACK ).ManaDamage# )
				if Unit( n ).RandomValue = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease1.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease1.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease1.mSpeed# )
				if Unit( n ).RandomValue = 1 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease2.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease2.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease2.mSpeed# )
				if Unit( n ).RandomValue = 2 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease3.mStart , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease3.mEnd , Unit( n ).Anim.ChangelingGroundMeleeAttackRelease3.mSpeed# )
				Unit( n ).Active = 22
			endif
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 2.0 / TBM.delta# )
			
			rem rotate towards target
			if Unit( n ).FollowUnit > -1 then Unit( n ).angle.y# = curveangle( 270 - atanfull( Unit( n ).pos.z# - Unit( Unit( n ).FollowUnit ).pos.z# , Unit( n ).pos.x# - Unit( Unit( n ).FollowUnit ).pos.x# ) , Unit( n ).angle.y# , 1.0 / TBM.delta# )
			_Unit_Handle_Ground_Movement( n )
			
			rem player has the option to cancel attack
			rem if the player is clicking on an enemy, don't do this check
			if Mouse.click > 0 then success = GetUnitUnderMouse()
			if success > -1
				if Unit( success ).Control = Unit( n ).Control then success = -1
			endif
			if success = -1
				if Unit( n ).Selected > 1
					_Unit_Activate_Any_Abilities( n )
					_Unit_Create_Ground_Path_With_Mouse( n )
				endif
			endif
			
			rem break if ability changes
			if Unit( n ).Ability.Active <> UNITABILITY_CHANGELING_MELEE_ATTACK then Unit( n ).Active = 2
			
		endif
		
		rem changeling melee attack released
		if Unit( n ).Active = 22
			
			rem if animation stopped, return to idle state
			if ObjectPlaying( Unit( n ).Obj ) = 0
				Unit( n ).Active = 2
				
				rem if not automatic, disable again
				if Unit( n ).Ability.Automatic <> UNITABILITY_CHANGELING_MELEE_ATTACK
					Unit( n ).AttackActive = 0
					Unit( n ).Ability.Active = -1
					Unit( n ).FollowUnit = -1
				endif
			endif
			
			rem slow unit down
			Unit( n ).CurrentSpeed# = curvevalue( 0 , Unit( n ).CurrentSpeed# , 2.0 / TBM.delta# )
			
			rem rotate towards target
			if Unit( n ).FollowUnit > -1 then Unit( n ).angle.y# = curveangle( 270 - atanfull( Unit( n ).pos.z# - Unit( Unit( n ).FollowUnit ).pos.z# , Unit( n ).pos.x# - Unit( Unit( n ).FollowUnit ).pos.x# ) , Unit( n ).angle.y# , 1.0 / TBM.delta# )
			_Unit_Handle_Ground_Movement( n )
			
			rem player has the option to cancel attack
			rem if the player is clicking on an enemy, don't do this check
			if Mouse.click > 0 then success = GetUnitUnderMouse()
			if success > -1
				if Unit( success ).Control = Unit( n ).Control then success = -1
			endif
			if success = -1
				if Unit( n ).Selected > 1
					_Unit_Activate_Any_Abilities( n )
					_Unit_Create_Ground_Path_With_Mouse( n )
				endif
			endif
			
			rem break if ability changes
			if Unit( n ).Ability.Active <> UNITABILITY_CHANGELING_MELEE_ATTACK then Unit( n ).Active = 2
			
		endif
		
		rem generic checks
		if Unit( n ).Active > 1
			
			rem check if selecting units is enabled
			if UnitBoxSelect.state = UNITBOXSELECT_ENABLE
				
				rem reset success
				success = 0
				
				rem get screen coordinates of unit
				rem if object in screen( Unit( n ).Obj )
					sx = object screen x( Unit( n ).Obj )
					sy = object screen y( Unit( n ).Obj )
				rem else
				rem 	sx = 10000
				rem 	sy = 10000
				rem endif
			
				rem a box is being dragged
				if UnitBoxSelect.Active > 0
					
					rem check if they are inside the box
					if UnitBoxSelect.sx > UnitBoxSelect.ex
						if sx > UnitBoxSelect.ex and sx < UnitBoxSelect.sx then success = 1
					else
						if sx < UnitBoxSelect.ex and sx > UnitBoxSelect.sx then success = 1
					endif
					if success = 1
						if UnitBoxSelect.sy < UnitBoxSelect.ey
							if sy > UnitBoxSelect.ey or sy < UnitBoxSelect.sy then success = 0
						else
							if sy < UnitBoxSelect.ey or sy > UnitBoxSelect.sy then success = 0
						endif
					endif
					
				endif
				
				rem single click units
				if GUI.MouseClickInvalid = 0
					if (sx - Mouse.x)^2 + (sy - Mouse.y)^2 < (Unit( n ).Size#*14)^2
						
						rem if player right clicks, set all selected units to follow
						if Mouse.Click = 4
							for s = 0 to Unit.CurrentMax
								if s <> n
									if Unit( s ).Active > 1
										if Unit( s ).Selected > 1
											Unit( s ).WasSetToFollowUnit = n
										endif
									endif
								endif
							next s
						endif

						rem mouse is over a unit
						success = 1
					endif
				endif
				
				rem process selections
				rem 0 - not selected
				rem 1 - half selected
				rem 2 - selected
				rem 3 - selected and half selected
				if success = 1
					if Unit( n ).Selected = 0 then Unit( n ).Selected = 1
					if Unit( n ).Selected = 2 then Unit( n ).Selected = 3
				else
					if Unit( n ).Selected = 1 then Unit( n ).Selected = 0
					if Unit( n ).Selected = 3 then Unit( n ).Selected = 2
				endif
				
			endif
			
			rem deselect any units that were previously selected
			rem if an ability was activated, unit can't be deselected
			rem if the user is holding shift, units can't be deselected
			if Mouse.Click = 1 and Unit.DisableUnitDeselect = 0 and GUI.MouseClickInvalid = 0 and shiftkey() = 0
				if Unit( n ).Selected = 2
					Unit( n ).Selected = 0
					Button.Clicked = -1
					HideUnitPath( n )
				endif
			endif
			
			rem a box has been dragged (mouse has let go)
			if UnitBoxSelect.Active = 2
				
				rem select any units that are half selected
				if Unit( n ).Selected = 1 or Unit( n ).Selected = 3
					
					rem select
					Unit( n ).Selected = 2
					Unit( n ).WasSelected = 1
					
				endif
				
			endif
			
			rem contorl half selected object
			if Unit( n ).Selected = 1 or Unit( n ).Selected = 3
				position object Unit( n ).HalfSelectObj , Unit( n ).pos.x# , Unit( n ).pos.y# + Unit( n ).HeightOffset# + 0.2 , Unit( n ).pos.z#
				rotate limb Unit( n ).HalfSelectObj , 0 , 0 , wrapvalue( limb angle y( Unit( n ).HalfSelectObj , 0 ) + (7 * TBM.delta#) ) , 0
				show object Unit( n ).HalfSelectObj
				
				rem control tilting
				if Unit( n ).HeightOffset# < 0.5
					TiltObjectToTerrain( Unit( n ).HalfSelectObj )
				else
					rotate object Unit( n ).HalfSelectObj , curveangle( 0 , object angle x(Unit( n ).HalfSelectObj) , 2.0 / TBM.delta# ) , 0 , curveangle( 0 , object angle z(Unit( n ).HalfSelectObj) , 2.0 / TBM.delta# )
				endif
			else
				hide object Unit( n ).HalfSelectObj
			endif
			
			rem control fully selected object
			if Unit( n ).Selected = 2 or Unit( n ).Selected = 3
				position object Unit( n ).SelectObj , Unit( n ).pos.x# , Unit( n ).pos.y# + Unit( n ).HeightOffset# + 0.2 , Unit( n ).pos.z#
				show object Unit( n ).SelectObj
				if Unit( n ).HeightOffset# < 0.5
					TiltObjectToTerrain( Unit( n ).SelectObj )
				else
					rotate object Unit( n ).SelectObj , curveangle( 0 , object angle x(Unit( n ).SelectObj) , 2.0 / TBM.delta# ) , 0 , curveangle( 0 , object angle z(Unit( n ).SelectObj) , 2.0 / TBM.delta# )
				endif
			else
				hide object Unit( n ).SelectObj
			endif
			
			rem if unit is idle and not in attack mode, check if it can attack enemies with automatic attack
			if Unit( n ).CurrentMaxPath = -1 and Unit( n ).Ability.Active = -1 and Unit( n ).FollowUnit = -1
				if Unit( n ).Ability.Automatic > -1
					
					rem check if an enemy unit is in range
					for s = 0 to Unit.CurrentMax
						if Unit( s ).Active > 1
							if Unit( s ).Control <> Unit( n ).Control and Unit( n ).Control <> UNITCONTROL_NOONE
								if (Unit( s ).pos.x# - Unit( n ).pos.x#)^2 + (Unit( s ).pos.z# - Unit( n ).pos.z#)^2 < Unit( n ).GroundViewRange#^2
									exit
								endif
							endif
						endif
					next s
					if s < Unit.CurrentMax + 1
						
						rem lock on to unit
						Unit( n ).FollowUnit = s
						Unit( n ).Ability.Active = Unit( n ).Ability.Automatic
						
					endif
					
				endif
				
			endif
			
			rem process recoil values
			Unit( n ).Stats.HealthRecoil# = curvevalue( Unit( n ).Stats.CurrentHealth# , Unit( n ).Stats.HealthRecoil# , 4.0 / TBM.delta# )
			Unit( n ).Stats.ManaRecoil# = curvevalue( Unit( n ).Stats.CurrentMana# , Unit( n ).Stats.ManaRecoil# , 4.0 / TBM.delta# )
			Unit( n ).Stats.ShieldRecoil# = curvevalue( Unit( n ).Stats.CurrentShield# , Unit( n ).Stats.ShieldRecoil# , 4.0 / TBM.delta# )
			
			rem only draw bars if unit is selected or ALT is pressed
			if keystate(56) or Unit( n ).Selected > 0
				
				rem draw health bar
				success = Unit( n ).Stats.HealthEnable
				if success = 1 and Unit( n ).Stats.ShieldEnable = 0
					a2box sx - 40 , sy - 80 , sx + 40 , sy - 75 , 0x80808080
					a2fillbox sx - 39 , sy - 79 , sx - 38 + ((Unit( n ).Stats.HealthRecoil# * 78) / Unit( n ).Stats.MaxHealth ) , sy - 75 , 0xFFFF0000
					a2fillbox sx - 39 , sy - 79 , sx - 38 + ((Unit( n ).Stats.CurrentHealth# * 78) / Unit( n ).Stats.MaxHealth ) , sy - 75 , 0xFF00FF50
				endif
				
				rem draw health and shield bar
				if success = 1 and Unit( n ).Stats.ShieldEnable = 1
					a2box sx - 40 , sy - 80 , sx + 40 , sy - 75 , 0x80808080
					a2line sx , sy - 79 , sx , sy - 75 , 0x80808080
					a2fillbox sx - 39 , sy - 79 , sx - 37 + ((Unit( n ).Stats.HealthRecoil# * 38) / Unit( n ).Stats.MaxHealth ) , sy -  75 , 0xFFFF0000
					a2fillbox sx + 1 , sy - 79 , sx + 2 + ((Unit( n ).Stats.ShieldRecoil# * 38) / Unit( n ).Stats.MaxShield ) , sy - 75 , 0xFFFF0000
					a2fillbox sx - 39 , sy - 79 , sx - 37 + ((Unit( n ).Stats.CurrentHealth# * 38) / Unit( n ).Stats.MaxHealth ) , sy -  75 , 0xFF00FF50
					a2fillbox sx + 1 , sy - 79 , sx + 2 + ((Unit( n ).Stats.CurrentShield# * 38) / Unit( n ).Stats.MaxShield ) , sy - 75 , 0xFFF000FF
				endif
				
				rem draw mana bar
				if Unit( n ).Stats.ManaEnable = 1
					a2box sx - 40 , sy - 75 , sx + 40 , sy - 70 , 0x80808080
					a2fillbox sx - 39 , sy - 74 , sx - 38 + ((Unit( n ).Stats.ManaRecoil# * 78) / Unit( n ).Stats.MaxMana ) , sy - 70 , 0xFFFF0000
					a2fillbox sx - 39 , sy - 74 , sx - 38 + ((Unit( n ).Stats.CurrentMana# * 78) / Unit( n ).Stats.MaxMana ) , sy - 70 , 0xFF0060FF
				endif
				
			endif
			
			rem if at any point the health drops to 0, kill unit
			if Unit( n ).Stats.CurrentHealth# = 0.0 and (Unit( n ).Active < 16 or Unit( n ).Active > 18) then Unit( n ).Active = 16
			
			rem move unit to next wayopint
			Unit( n ).pos.x# = newxvalue( Unit( n ).pos.x# , Unit( n ).angle.y# , Unit( n ).CurrentSpeed# * TBM.delta# )
			Unit( n ).pos.z# = newzvalue( Unit( n ).pos.z# , Unit( n ).angle.y# , Unit( n ).CurrentSpeed# * TBM.delta#)
			
			rem handle collision with other units
			for sx = 0 to Unit.CurrentMax
				if Unit( sx ).Active > 1
					if sx <> n
						dist# = ((Unit( n ).pos.x# - Unit( sx ).pos.x#)^2 + ((Unit( n ).pos.y# + Unit( n ).HeightOffset#) - (Unit( sx ).pos.y# + Unit( sx ).HeightOffset#))^2 + (Unit( n ).pos.z# - Unit( sx ).pos.z#)^2)^0.5
						if dist# < Unit( n ).Size#
							
							rem handle collision for units with not the same control
							a# = 90 - atanfull( Unit( n ).pos.z# - Unit( sx ).pos.z# , Unit( n ).pos.x# - Unit( sx ).pos.x# )
							if Unit( n ).Control <> Unit( sx ).Control
								if Unit( n ).Control = UNITCONTROL_PLAYER
									Unit( n ).pos.x# = newxvalue( Unit( n ).pos.x# , a# , (Unit( n ).Size#) - dist# )
									Unit( n ).pos.z# = newzvalue( Unit( n ).pos.z# , a# , (Unit( n ).Size#) - dist# )
								endif
							else
								Unit( n ).pos.x# = curvevalue( newxvalue( Unit( n ).pos.x# , a# , (Unit( n ).Size#) - dist# ) , Unit( n ).pos.x# , 5.0 / TBM.delta# )
								Unit( n ).pos.z# = curvevalue( newzvalue( Unit( n ).pos.z# , a# , (Unit( n ).Size#) - dist# ) , Unit( n ).pos.z# , 5.0 / TBM.delta# )
							endif
							
						endif
					endif
				endif
			next sx
			
			rem update unit positions
			position object Unit( n ).Obj , Unit( n ).pos.x# , Unit( n ).pos.y# + Unit( n ).HeightOffset# , Unit( n ).pos.z#
			rotate limb Unit( n ).Obj , 0 , 0 , Unit( n ).angle.y# , 0
			
			rem store old postitions
			Unit( n ).oldpos = Unit( n ).pos

		endif
	
	next n
	
	rem post actions for units (avoids weird conflicts)
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1
			
			rem set unit to follow
			if Unit( n ).WasSetToFollowUnit > -1
				
				rem set unit to follow
				Unit( n ).FollowUnit = Unit( n ).WasSetToFollowUnit
				
				rem if unit is hostile, attack it with automatic attack (if available)
				if Unit( n ).Control <> Unit( Unit( n ).FollowUnit ).Control and Unit( Unit( n ).FollowUnit ).Control <> UNITCONTROL_NOONE
					if Unit( n ).Ability.Automatic > -1
						Unit( n ).Ability.Active = Unit( n ).Ability.Automatic
					endif
				endif
				
				rem reset flag
				Unit( n ).WasSetToFollowUnit = -1
			endif
			
			rem unit was selected
			if Unit( n ).WasSelected = 1
				
				rem show unit path
				ShowUnitPath( n )
				
				rem prioritise unit selection
				for s = 0 to Unit.CurrentMax
					if s <> n
						if Unit( s ).Active > 1
							if Unit( s ).Selected > 1
								
								rem neutral over hostile
								if Unit( s ).Control = UNITCONTROL_NOONE
									if Unit( n ).Control = UNITCONTROL_ENEMY then Unit( n ).Selected = 0
								endif
								
								rem friendly over neutral and hostile
								if Unit( s ).Control = UNITCONTROL_PLAYER
									if Unit( n ).Control = UNITCONTROL_NOONE or Unit( n ).Control = UNITCONTROL_ENEMY then Unit( n ).Selected = 0
								endif
								
							endif
						endif
					endif
				next s
				
				rem reset flag
				Unit( n ).WasSelected = 0
				
			endif
		endif
	next n
	
	rem reset button clicked
	if Unit.PostResetButtonClicked = 1 then Button.Clicked = -1
	
	rem handle formations
	rem ControlFormation()

endfunction

function TiltObjectToTerrain( Obj )
	
	rem tilt
	if SC_RayCastGroup( COL_TERRAIN , object position x( Obj ) , 200 , object position z( Obj ) , object position x( Obj ) , -200 , object position z( Obj ) , 0 )
		rotate object Obj , curveangle( asin( SC_GetCollisionNormalZ() ) , object angle x( Obj ) , 3.0 / TBM.delta# ) , 0 , curveangle( asin( 0 - SC_GetCollisionNormalX() ) , object angle z( Obj ) , 3.0 / TBM.delta# )
	endif
	
endfunction

function GetUnitUnderMouse()
	
	rem local variables
	local n as integer
	
	rem loop through all active units
	for n = 0 to Unit.CurrentMax
		if Unit( n ).Active > 1
			if (object screen x( Unit( n ).Obj ) - Mouse.x)^2 + (object screen y( Unit( n ).Obj ) - Mouse.y)^2 < (Unit( n ).Size#*14)^2
				exitfunction n
			endif
		endif
	next n
	
endfunction -1

function _Unit_Handle_Ground_Following( n )
	
	rem if unit is in range, stop following
	if (Unit( n ).pos.x#-Unit( Unit( n ).FollowUnit ).pos.x#)^2 + (Unit( n ).pos.z#-Unit( Unit( n ).FollowUnit ).pos.z#)^2 < (Unit( n ).Size#*1.5)^2
		if Unit( n ).CurrentMaxPath > -1 then ResetUnitPath( n )
	else
	
		rem if unit is not in range, find path to it
		if timer() - Unit( n ).FollowUnitDelayTimer > 400
			ResetUnitPath( n )
			UnitCalculatePath( n , Unit( n ).pos.x# , Unit( n ).pos.z# , Unit( Unit( n ).FollowUnit ).pos.x# , Unit( Unit( n ).FollowUnit ).pos.z# )
		endif
	
	endif
				
endfunction
	
function _Unit_Handle_Ground_Movement( n )
	
	rem decrease offset to 0 if still in air
	if Unit( n ).HeightOffset# > 0 then dec Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
	if Unit( n ).HeightOffset# < 0 then Unit( n ).HeightOffset# = 0

	rem position at terrain height
	if SC_RayCastGroup( COL_TERRAIN , Unit( n ).pos.x# , 200 , Unit( n ).pos.z# , Unit( n ).pos.x# , -200 , Unit( n ).pos.z# , 0 )
		Unit( n ).pos.y# = curvevalue( SC_GetStaticCollisionY() , Unit( n ).pos.y# , 0.2 / TBM.delta# )
	else
		Unit( n ).pos.y# = curvevalue( 0 , Unit( n ).pos.y# , 0.5 / TBM.delta# )
	endif
	
	rem collision with pathfinding walls
	if SC_SphereCastGroup( COL_PATHFINDER , Unit( n ).oldpos.x# , Unit( n ).oldpos.y# + (Unit( n ).Size#/2)-0.1 , Unit( n ).oldpos.z# , Unit( n ).pos.x# , Unit( n ).pos.y# + (Unit( n ).Size#/2) , Unit( n ).pos.z# , Unit( n ).Size# / 3 , 0 )
		Unit( n ).pos.x# = SC_GetCollisionSlideX()
		Unit( n ).pos.z# = SC_GetCollisionSlideZ()
	endif
	
	rem tilt to terrain
	TiltObjectToTerrain( Unit( n ).Obj )
	
endfunction

function _Unit_Handle_Ground_Animations( n )
	
	rem idle animation
	if Unit( n ).CurrentSpeed# < Unit( n ).GroundSpeed# * 0.01
		if ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.Idle.mStart or ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.Idle.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.Idle.mStart , Unit( n ).Anim.Idle.mEnd , Unit( n ).Anim.Idle.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.Idle.mStart , Unit( n ).Anim.Idle.mEnd , Unit( n ).Anim.Idle.mSpeed# )
	endif
	
	rem creep animation
	if Unit( n ).CurrentSpeed# > Unit( n ).GroundSpeed# * 0.01 and Unit( n ).CurrentSpeed# < Unit( n ).GroundSpeed# * 0.333
		if ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.Creep.mStart or ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.Creep.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.Creep.mStart , Unit( n ).Anim.Creep.mEnd , Unit( n ).Anim.Creep.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.Creep.mStart , Unit( n ).Anim.Creep.mEnd , Unit( n ).Anim.Creep.mSpeed# )
	endif
	
	rem walk animation
	if Unit( n ).CurrentSpeed# > Unit( n ).GroundSpeed# * 0.333 and Unit( n ).CurrentSpeed# < Unit( n ).GroundSpeed# * 0.666
		if ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.Walk.mStart or ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.Walk.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.Walk.mStart , Unit( n ).Anim.Walk.mEnd , Unit( n ).Anim.Walk.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.Walk.mStart , Unit( n ).Anim.Walk.mEnd , Unit( n ).Anim.Walk.mSpeed# )
	endif
	
	rem run animation
	if Unit( n ).CurrentSpeed# > Unit( n ).GroundSpeed# * 0.666
		if ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.Run.mStart or ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.Run.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.Run.mStart , Unit( n ).Anim.Run.mEnd , Unit( n ).Anim.Run.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.Run.mStart , Unit( n ).Anim.Run.mEnd , Unit( n ).Anim.Run.mSpeed# )
	endif
	
endfunction

function _Unit_Handle_Air_Animations( n )
	
	rem control idle flying animation
	if Unit( n ).CurrentSpeed# < Unit( n ).AirSpeed# * 0.333
		if ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.Fly.mStart and ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.Fly.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.FlyToFlyIdle.mStart , Unit( n ).Anim.FlyToFlyIdle.mEnd , Unit( n ).Anim.FlyToFlyIdle.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.FlyIdle.mStart , Unit( n ).Anim.FlyIdle.mEnd , Unit( n ).Anim.FlyIdle.mSpeed# )
	endif
	
	rem control transitions and flying animations
	if Unit( n ).CurrentSpeed# > Unit( n ).AirSpeed# * 0.333
		if ObjectFrame( Unit( n ).Obj ) > Unit( n ).Anim.FlyIdle.mStart and ObjectFrame( Unit( n ).Obj ) < Unit( n ).Anim.FlyIdle.mEnd
			StopObject( Unit( n ).Obj )
			PlayObject( Unit( n ).Obj , Unit( n ).Anim.FlyIdleToFly.mStart , Unit( n ).Anim.FlyIdleToFly.mEnd , Unit( n ).Anim.FlyIdleToFly.mSpeed# )
		endif
		if ObjectPlaying( Unit( n ).Obj ) = 0 then PlayObject( Unit( n ).Obj , Unit( n ).Anim.Fly.mStart , Unit( n ).Anim.Fly.mEnd , Unit( n ).Anim.Fly.mSpeed# )
	endif
			
endfunction

function _Unit_Handle_Air_Movement( n )
	
	rem increase offset to 5 if still in air
	if Unit( n ).HeightOffset# < 5 then inc Unit( n ).HeightOffset# , 0.4 * TBM.Delta#
	if Unit( n ).HeightOffset# > 5 then Unit( n ).HeightOffset# = 5
	
	rem position at terrain height
	if SC_RayCastGroup( COL_TERRAIN , Unit( n ).pos.x# , 200 , Unit( n ).pos.z# , Unit( n ).pos.x# , -200 , Unit( n ).pos.z# , 0 )
		Unit( n ).pos.y# = curvevalue( SC_GetStaticCollisionY() , Unit( n ).pos.y# , 4.0 / TBM.delta# )
	else
		Unit( n ).pos.y# = curvevalue( 0 , Unit( n ).pos.y# , 4.0 / TBM.delta# )
	endif
			
endfunction

function DamageUnit( n , health# , mana# )
	
	rem do damage to shield first
	if Unit( n ).Stats.ShieldEnable = 1
		dec Unit( n ).Stats.CurrentShield# , health#
	
		rem if shield is gone, do damage to health
		if Unit( n ).Stats.CurrentShield# < 0.0
			inc Unit( n ).Stats.CurrentHealth# , Unit( n ).Stats.CurrentShield#
			Unit( n ).Stats.CurrentShield# = 0.0
		endif
		
	rem do damage to health
	else
		dec Unit( n ).Stats.CurrentHealth# , health#
	endif
	
	rem damage to mana
	if Unit( n ).Stats.ManaEnable = 1
		dec Unit( n ).Stats.CurrentMana# , mana#
		if Unit( n ).Stats.CurrentMana# < 0.0 then Unit( n ).Stats.CurrentMana# = 0.0
	endif
	
	rem health can't go below 0
	if Unit( n ).Stats.CurrentHealth# < 0.0 then Unit( n ).Stats.CurrentHealth# = 0.0

endfunction
rem ---------------------------------------------------------------------------
rem Scripts
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant ScriptMax									100

#constant SCRIPTDATA_FLOAT							0
#constant SCRIPTDATA_INTEGER						1
#constant SCRIPTDATA_STRING						2
#constant SCRIPTDATA_DYNAMIC						3

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type ScriptVT
	CurrentSelected                        	as integer
	SaveIndex                              	as integer
	logging												as integer
	CurrentConsoleCmdMax								as integer
	CurrentIntegerDataMax							as integer
	CurrentFloatDataMax								as integer
	CurrentStringDataMax								as integer
	CurrentDataListMax                        as integer
endtype

type ScriptAAT
	Active                                 	as integer
	CurrentLine                            	as integer
	CurrentDataListCount                      as integer
	cmd													as integer
	Dat													as integer
endtype

type ScriptIntegerDataAT
	Active												as integer
	dat													as integer
endtype

type ScriptFloatDataAT
	Active												as integer
	dat#													as float
endtype

type ScriptStringDataAT
	Active												as integer
	dat$													as string
endtype

type ScriptDataListAAT
   Active                                    as integer
   Index                                     as dword
   DatType                                   as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitScript()
	
	rem debug
	DebugOutput( 0 , "Initialising Scripts" )
	
	rem ---------------------------------------------------------------------------
	rem Global Variables
	rem ---------------------------------------------------------------------------
	
	global Script                          	as ScriptVT

	rem ---------------------------------------------------------------------------
	rem User Defined Types
	rem ---------------------------------------------------------------------------
	
	global dim ConsoleCmd$(30) 					as string
	global dim Script( ScriptMax , 1024 )  	as ScriptAAT
	global dim ScriptDataList( ScriptMax , -1 ) as ScriptDataListAAT
	global dim ScriptIntegerData()				as ScriptIntegerDataAT
	global dim ScriptFloatData()					as ScriptFloatDataAT
	global dim ScriptStringData()					as ScriptStringDataAT
	
	rem initial values
	Script.CurrentConsoleCmdMax = -1
	Script.CurrentIntegerDataMax = -1
	Script.CurrentFloatDataMax = -1
	Script.CurrentStringDataMax = -1
	Script.CurrentDataListMax = -1

endfunction

function LoadScript( filename$ , Index )
	
	rem destroy the script
	DestroyScript( Index )
	
	rem check if file exists
	if file exist( filename$ )
		
		rem debug
		DebugOutput( 0 , "Loading script " + chr$(34) + filename$ + chr$(34) )
		
		rem reset values
		Script( Index , 0 ).Active = 1
		Script( Index , 0 ).CurrentLine = 0
		
		rem open file
		OpenToRead( 1 , filename$ )
		
			rem loop until end of file is reached
			repeat
				
				rem read in command
				read string 1 , cmd$
				
				rem check if command should be ignored
				if cmd$ = "" or left$( cmd$ , 2 ) = "//"
				else
					if CompileEntry( cmd$ , Index+1 , Script( Index , 0 ).CurrentLine ) > -1 then inc Script( Index , 0 ).CurrentLine
				endif
				
			until file end( 1 )
		close file 1
	else
		DebugOutput( 3 , "Script " + chr$(34) + filename$ + chr$(34) + " does not exist." )
		exitfunction -1
	endif

endfunction 0

function RunScript( Index )
	
	rem local variables
	local n as integer

	rem set script to execute
	Script( Index , 0 ).Active = 2
	Script( Index , 0 ).CurrentLine = 0
	
	remstart iteration disabled
	n = 0
	repeat
		if lower$(Script( Index , n ).cmd$) = "disableiteration " then Script( Index , 0 ).Active = 3
		inc n
	until lower$(Script( Index , n ).cmd$) = "end" or n > 1023
	remend

	rem process all commands at once
	if Script( Index , 0 ).Active = 3
		repeat
			Script.CurrentSelected = Index
			ProcessEntry( Index , Script( Index , 0 ).CurrentLine )
			inc Script( Index , 0 ).CurrentLine
		until Script( Index , 0 ).Active < 2 or Script( Index , 0 ).CurrentLine > 1023
	endif

endfunction

function StopScript( Index )
	
	rem set script to stop
	Script( Index , 0 ).Active = 1
	
endfunction

function DestroyScript( Index )

   rem local variables
   local n as integer
	
	rem remove any stored data
	for n = 0 to Script( Index , 0 ).CurrentDataListCount
      rem ScriptRemoveData( Script , n )
   next n
   
   rem reset data list counter
   rem Script( Index , 0 ).CurrentDataListCount = -1
	
endfunction

function ScriptAddDataInteger( dat )
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to Script.CurrentIntegerDataMax
		if ScriptIntegerData( n ).Active = 0 then exit
	next n
	
	rem none found, create
	if n = Script.CurrentIntegerDataMax + 1
		array insert at bottom ScriptIntegerData()
		inc Script.CurrentIntegerDataMax
	endif
	
	rem add data
	ScriptIntegerData( n ).Active = 2
	ScriptIntegerData( n ).dat = dat
	
endfunction n

function ScriptAddDataFloat( dat# )
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to Script.CurrentFloatDataMax
		if ScriptFloatData( n ).Active = 0 then exit
	next n
	
	rem none found, create
	if n = Script.CurrentFloatDataMax + 1
		array insert at bottom ScriptFloatData()
		inc Script.CurrentFloatDataMax
	endif
	
	rem add data
	ScriptFloatData( n ).Active = 2
	ScriptFloatData( n ).dat# = dat#
	
endfunction n

function ScriptAddDataString( dat$ )
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to Script.CurrentStringDataMax
		if ScriptStringData( n ).Active = 0 then exit
	next n
	
	rem none found, create
	if n = Script.CurrentStringDataMax + 1
		array insert at bottom ScriptStringData()
		inc Script.CurrentStringDataMax
	endif
	
	rem add data
	ScriptStringData( n ).Active = 2
	ScriptStringData( n ).dat$ = dat$
	
endfunction n

function ScriptAddDataIndexToList( Script , index , DataType )

   rem local variables
   local n as integer
   
   rem find free slot
   for n = 0 to Script.CurrentDataListMax
      if ScriptDataList( Script , n ).Active = 0 then exit
   next n
   
   rem no free slot, create
   if n = Script.CurrentDataListMax + 1
      dim ScriptDataList( ScriptMax , n ) as ScriptDataListAAT
      inc Script.CurrentDataListMax
   endif
   
   rem save
   ScriptDataList( Script , n ).Active = 2
   ScriptDataList( Script , n ).Index = index
   ScriptDataList( Script , n ).DatType = DataType
   inc Script( Script , 0 ).CurrentDataListCount
   
endfunction n

function ScriptRemoveDataInteger( n )
	ScriptIntegerData( n ).Active = 0
endfunction

function ScriptRemoveDataFloat( n )
	ScriptFloatData( n ).Active = 0
endfunction

function ScriptRemoveDataString( n )
	ScriptStringData( n ).Active = 0
endfunction

function ScriptRemoveData( Script , index )
   if ScriptDataList( Script , index ).DatType = SCRIPTDATA_INTEGER then ScriptRemoveDataInteger( ScriptDataList( Script , index ).Index )
   if ScriptDataList( Script , index ).DatType = SCRIPTDATA_FLOAT then ScriptRemoveDataFloat( ScriptDataList( Script , index ).Index )
   if ScriptDataList( Script , index ).DatType = SCRIPTDATA_STRING then ScriptRemoveDataString( ScriptDataList( Script , index ).Index )
   ScriptdataList( Script , index ).Active = 0
endfunction

function ControlScript()
	
	rem local variables
	local n as integer
	local l as integer
	
	rem loop through all active scripts
	for n = 0 to ScriptMax
		
		rem current selected
		Script.CurrentSelected = n
		
		rem process one command every loop (default)
		if Script( n , 0 ).Active = 2
			ProcessEntry( Script( n , Script( n , 0 ).CurrentLine ).cmd$ )
			inc Script( n , 0 ).CurrentLine
		endif
		
	next n
	
endfunction

function SetAllLoggingFlags( n )
	
	rem set all logging flags
	Animation.logging                   = n
	Camera.logging                      = n
	ClickObj.logging                    = n
	Distortion.logging                  = n
	GUI.logging                         = n
	MagicMissile.logging                = n
	Menu.logging                        = n
	Message.logging                     = n
	Script.logging 							= n
	Trigger.logging                     = n
	Unit.logging                        = n
	UnitBoxSelect.logging               = n
	World.logging                       = n
	
endfunction
rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

rem help
#constant CMD_HELP										0
#constant CMD_HELPCORE									1
#constant CMD_HELPGAMECONTROLS						2
#constant CMD_HELPLOGGING								3
#constant CMD_HELPCAMERA								4
#constant CMD_HELPCLICKOBJ								5
#constant CMD_HELPDISTORTION							6
#constant CMD_HELPGUI									7
#constant CMD_HELPMENU									8
#constant CMD_HELPMESSAGE								9
#constant CMD_HELPSCRIPT								10
#constant CMD_HELPTEXTENTRY							11
#constant CMD_HELPTRIGGER								12
#constant CMD_HELPUNIT									13
#constant CMD_HELPWORLD									14

rem core
#constant CMD_SETCONSOLESIZE							1000
#constant CMD_SETCONSOLEPOSITION						1001
#constant CMD_OPENTOREAD								1002
#constant CMD_OPENTOWRITE								1003
#constant CMD_CLOSEFILE									1004
#constant CMD_READFILEBLOCK							1005
#constant CMD_WRITEFILEBLOCK							1006
#constant CMD_WRITELONG									1007
#constant CMD_WRITEFLOAT								1008
#constant CMD_WRITEBYTE									1009

rem game controls
#constant CMD_CTRL_BUTTON                       2000
#constant CMD_CTRL_CAMERA                       2001
#constant CMD_CTRL_CLICKOBJ                     2002
#constant CMD_CTRL_CONSOLE                      2003
#constant CMD_CTRL_DISTORTION                   2004
#constant CMD_CTRL_GUI                          2005
#constant CMD_CTRL_MENU                         2006
#constant CMD_CTRL_MESSAGE                      2007
#constant CMD_CTRL_MOUSE                        2008
#constant CMD_CTRL_SCRIPT                       2009
#constant CMD_CTRL_SLIDER                       2010
#constant CMD_CTRL_TEXTENTRY                    2011
#constant CMD_CTRL_TRIGGER                      2012
#constant CMD_CTRL_UNIT                         2013
#constant CMD_CTRL_UNITBOXSELECT                2014
#constant CMD_CTRL_WORLD                        2015

rem game controls
#constant CMD_TURNALLLOGGINGON                  3000
#constant CMD_TURNALLLOGGINGOFF                 3001
#constant CMD_CAMERALOGGING                     3002
#constant CMD_CLICKOBJLOGGING                   3003
#constant CMD_DISTORTIONLOGGING                 3004
#constant CMD_GUILOGGING                        3005
#constant CMD_MENULOGGING                       3006
#constant CMD_MESSAGELOGGING                    3007
#constant CMD_SCRIPTLOGGING                     3008
#constant CMD_TRIGGERLOGGING                    3009
#constant CMD_UNITLOGGING                       3010
#constant CMD_UNITBOXSELECTLOGGING              3011
#constant CMD_WORLDLOGGING                      3012

rem camera commands
#constant CMD_SETCAMERAMODE                     4000

rem click object commands
#constant CMD_CREATECLICKOBJ                    4000
#constant CMD_DESTROYCLICKOBJ                   4001
#constant CMD_CREATECLICKOBJCONNECTION          4002
#constant CMD_DESTROYCLICKOBJCONNECTION         4003
#constant CMD_SHOWCLICKOBJ                      4004
#constant CMD_SHOWCLICKOBJCONNECTION            4005
#constant CMD_HIDECLICKOBJ                      4006
#constant CMD_HIDECLICKOBJCONNECTION            4007

rem distortion commands
#constant CMD_CREATEDISTORTION                  5000
#constant CMD_DESTROYDISTORTION                 5001

rem gui commands
#constant CMD_GUIADDSTATICIMAGE                 6000
#constant CMD_GUIDESTROYELEMENT                 6001
#constant CMD_GUIADDBUTTON                      6002
#constant CMD_GUILOCKBUTTON                     6003
#constant CMD_GUIUNLOCKBUTTON                   6004
#constant CMD_GUIHIDEBUTTON                     6005
#constant CMD_GUISHOWBUTTON                     6006
#constant CMD_GUIBINDBUTTONTOUNIT               6007
#constant CMD_GUIUNBINDUNIT                     6008
#constant CMD_GUIPOSITIONBUTTON                 6009
#constant CMD_GUIPOSITIONSTATICIMAGE            6010

rem menu commands
#constant CMD_CREATESPLASH                      7000
#constant CMD_DESTROYSPLASH                     7001
#constant CMD_CREATEMENU                        7002
#constant CMD_DESTROYMENU                       7003

rem message commands
#constant CMD_CREATEMESSAGE                     8000
#constant CMD_DESTROYMESSAGE                    8001

rem script commands
#constant CMD_LOADSCRIPT                        9000
#constant CMD_RUNSCRIPT                         9001
#constant CMD_STOPSCRIPT                        9002

rem trigger commands
#constant CMD_CREATEAREATRIGGER                 10000
#constant CMD_CREATETIMERTRIGGER                10001
#constant CMD_CREATEUNITTIMERTRIGGER            10002
#constant CMD_DESTROYTRIGGER                    10003
#constant CMD_SHOWTRIGGER                       10004
#constant CMD_SHOWTRIGGERS                      10005
#constant CMD_HIDETRIGGERS                      10006

rem unit commands
#constant CMD_CREATEUNIT                        11001
#constant CMD_UNITADDABILITY                    11002
#constant CMD_UNITLOCKABILITY                   11003
#constant CMD_DESTROYUNIT                       11004
#constant CMD_UNITPOSITION                      11005
#constant CMD_UNITSCALE                         11006
#constant CMD_UNITUNLOCKABILITY                 11007
#constant CMD_UNITSETABILITYRANGE               11008
#constant CMD_UNITSETABILITYGLOBAL              11009
#constant CMD_UNITSETABILITYLOCAL               11010
#constant CMD_UNITSETABILITYHEALTHDAMAGE        11011
#constant CMD_UNITSETABILITYMANADAMAGE          11012
#constant CMD_UNITUSEABILITY                    11013
#constant CMD_UNITBOXSELECTENABLE               11014
#constant CMD_UNITBOXSELECTDISABLE              11015
#constant CMD_UNITDRAWPATH                      11016
#constant CMD_UNITHIDEPATH                      11017
#constant CMD_UNITDRAWFORMATION                 11018
#constant CMD_UNITHIDEFORMATION                 11019

rem world commands
#constant CMD_DESTROYWORLD                      12000
#constant CMD_WORLDADDTERRAINOBJECT             12001
#constant CMD_WORLDCREATEPATHFINDER             12002
#constant CMD_WORLDSHOWPATHMAP                  12003
#constant CMD_WORLDHIDEPATHMAP                  12004
#constant CMD_WORLDCREATEFOGOFWAR               12005
#constant CMD_WORLDDESTROYFOGOFWAR              12006
#constant CMD_WORLDSHOWFOGOFWAR                 12007
#constant CMD_WORLDHIDEFOGOFWAR                 12008

function CompileEntry( string$ , slot , lin )
	
	rem local variables
	local n as integer
	local s as integer
	local SplitCount as integer
	
	rem logging
	if Script.logging = 1 then AddTextToConsole( "Compile -- " + chr$(34) + string$ + chr$(34) , 0xFF808080 , 0 )
	
	rem split string into array
	split string string$ , " "
	SplitCount = range( split count() , 0 , 30 )
	s = 0
	for n = 1 to SplitCount
		ConsoleCmd$(s) = get split word$(n)
		if ConsoleCmd$(s) <> "" then inc s
	next n
	
	rem clear end of array
	for n = SplitCount+1 to array count( ConsoleCmd$() )
		ConsoleCmd$(n) = ""
	next n
	
	rem pre-process static values
	for n = 1 to SplitCount

		rem unit control
		if ConsoleCmd$(n) = "unitcontrol_player" then ConsoleCmd$(n) = str$(UNITCONTROL_PLAYER)
		if ConsoleCmd$(n) = "unitcontrol_noone" then ConsoleCmd$(n) = str$(UNITCONTROL_NOONE)
		if ConsoleCmd$(n) = "unitcontrol_enemy" then ConsoleCmd$(n) = str$(UNITCONTROL_ENEMY)
		
		rem unit abilities
		if ConsoleCmd$(n) = "unitability_fly" then ConsoleCmd$(n) = str$(UNITABILITY_FLY)
		if ConsoleCmd$(n) = "unitability_land" then ConsoleCmd$(n) = str$(UNITABILITY_LAND)
		if ConsoleCmd$(n) = "unitability_magic_missile" then ConsoleCmd$(n) = str$(UNITABILITY_MAGIC_MISSILE)
		if ConsoleCmd$(n) = "unitability_move" then ConsoleCmd$(n) = str$(UNITABILITY_MOVE)
		if ConsoleCmd$(n) = "unitability_stop" then ConsoleCmd$(n) = str$(UNITABILITY_STOP)
		if ConsoleCmd$(n) = "unitability_hold" then ConsoleCmd$(n) = str$(UNITABILITY_HOLD)
		if ConsoleCmd$(n) = "unitability_patrol" then ConsoleCmd$(n) = str$(UNITABILITY_PATROL)
		if ConsoleCmd$(n) = "unitability_teleport" then ConsoleCmd$(n) = str$(UNITABILITY_TELEPORT)
		if ConsoleCmd$(n) = "unitability_changeling_melee_attack" then ConsoleCmd$(n) = str$(UNITABILITY_CHANGELING_MELEE_ATTACK)
		
	next n
	
	rem help
	if ConsoleCmd$(0) = "help"
		
		rem deeper help
		if ConsoleCmd$(1) = "core" then Script( slot , lin ).cmd = CMD_HELPCORE                    : exitfunction 0
		if ConsoleCmd$(1) = "gamecontrols" then Script( slot , lin ).cmd = CMD_HELPGAMECONTROLS    : exitfunction 0
		if ConsoleCmd$(1) = "logging" then Script( slot , lin  ).cmd = CMD_HELPLOGGING             : exitfunction 0
		if ConsoleCmd$(1) = "camera" then Script( slot , lin  ).cmd = CMD_HELPCAMERA               : exitfunction 0
		if ConsoleCmd$(1) = "clickobj" then Script( slot , lin  ).cmd = CMD_HELPCLICKOBJ           : exitfunction 0
		if ConsoleCmd$(1) = "distortion" then Script( slot , lin  ).cmd = CMD_HELPDISTORTION       : exitfunction 0
		if ConsoleCmd$(1) = "gui" then Script( slot , lin  ).cmd = CMD_HELPGUI                     : exitfunction 0
		if ConsoleCmd$(1) = "menu" then Script( slot , lin  ).cmd = CMD_HELPMENU                   : exitfunction 0
		if ConsoleCmd$(1) = "message" then Script( slot , lin  ).cmd = CMD_HELPMESSAGE             : exitfunction 0
		if ConsoleCmd$(1) = "script" then Script( slot , lin  ).cmd = CMD_HELPSCRIPT               : exitfunction 0
		if ConsoleCmd$(1) = "textentry" then Script( slot , lin  ).cmd = CMD_HELPTEXTENTRY         : exitfunction 0
		if ConsoleCmd$(1) = "trigger" then Script( slot , lin  ).cmd = CMD_HELPTRIGGER             : exitfunction 0
		if ConsoleCmd$(1) = "unit" then Script( slot , lin  ).cmd = CMD_HELPUNIT                   : exitfunction 0
		if ConsoleCmd$(1) = "world" then Script( slot , lin  ).cmd = CMD_HELPWORLD                 : exitfunction 0
		
		rem just help
		Script( slot , lin ).cmd = CMD_HELP : exitfunction 0
	endif
	
	rem core commands ------------------------------------------------------------
	if ConsoleCmd$(0) = "setconsolesize" then Script( slot , lin ).cmd = CMD_SETCONSOLESIZE : exitfunction 0
	if ConsoleCmd$(0) = "setconsoleposition" then Script( slot , lin ).cmd = CMD_SETCONSOLEPOSITION : exitfunction 0
	if ConsoleCmd$(0) = "opentoread"
      if ConsoleCmd$(2) = ""
         AddTextToConsole( "OpenToRead expects <filename> <file index>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_OPENTOREAD
      ScriptAddDataIndexToList( Script , ScriptAddDataString(ConsoleCmd$(1)) , SCRIPTDATA_STRING )
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(2))) , SCRIPTDATA_INTEGER )
      exitfunction 0
   endif
   
   if ConsoleCmd$(0) = "opentowrite"
      if ConsoleCmd$(2) = ""
         AddTextToConsole( "OpenToWrite expects <filename> <file index>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_OPENTOWRITE
      ScriptAddDataIndexToList( Script , ScriptAddDataString(ConsoleCmd$(1)) , SCRIPTDATA_STRING )
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(2))) , SCRIPTDATA_INTEGER )
      exitfunction 0
   endif
   
   if ConsoleCmd$(0) = "closefile"
      if ConsoleCmd$(1) = ""
         AddTextToConsole( "CloseFile expects <file index>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_CLOSEFILE
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(1))) , SCRIPTDATA_INTEGER )
      exitfunction 0
   endif
   
   if ConsoleCmd$(0) = "readfileblock"
      if ConsoleCmd$(2) = ""
         AddTextToConsole( "ReadFileBlock expects <file index> <output file>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_READFILEBLOCK
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(1))) , SCRIPTDATA_INTEGER )
      ScriptAddDataIndexToList( Script , ScriptAddDataString(ConsoleCmd$(2)) , SCRIPTDATA_STRING )
      exitfunction 0
   endif
   
   if ConsoleCmd$(0) = "writefileblock"
      if ConsoleCmd$(2) = ""
         AddTextToConsole( "WriteFileBlock expects <file index> <input file>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_WRITEFILEBLOCK
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(1))) , SCRIPTDATA_INTEGER )
      ScriptAddDataIndexToList( Script , ScriptAddDataString(ConsoleCmd$(2)) , SCRIPTDATA_STRING )
      exitfunction 0
   endif
   
   if ConsoleCmd(0) = "writelong"
      if ConsoleCmd$(1) = ""
         AddTextToConsole( "WriteLong expects <file index> <integer>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_WRITELONG
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(1))) , SCRIPTDATA_INTEGER )
      exitfunction 0
   endif
   
   if ConsoleCmd(0) = "writefloat"
      if ConsoleCmd$(1) = ""
         AddTextToConsole( "WriteFloat expects <file index> <float>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_WRITEFLOAT
      ScriptAddDataIndexToList( Script , ScriptAddDataFloat(val(ConsoleCmd$(1))) , SCRIPTDATA_FLOAT )
      exitfunction 0
   endif
   
   if ConsoleCmd(0) = "writebyte"
      if ConsoleCmd$(1) = ""
         AddTextToConsole( "WriteByte expects <file index> <byte>" , 0xFFFF0000 , 3 )
         exitfunction -1
      endif
      Script( slot , lin ).cmd = CMD_WRITEBYTE
      ScriptAddDataIndexToList( Script , ScriptAddDataInteger(val(ConsoleCmd$(1))) , SCRIPTDATA_INTEGER )
      exitfunction 0
   endif

endfunction -1

function ProcessEntry( slot , lin )
   
   rem help
   if Script( slot , lin ).cmd = CMD_HELP
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Core                                 - Core Commands" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "Help GameControls                         - Change Game Controls" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Logging                              - Change logging flags" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "Help Camera                               - Camera Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help ClickObj                             - Click Object Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Distortion                           - Distortion Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help GUI                                  - GUI Commands" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "Help Menu                                 - Menu Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Message                              - Message Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Script                               - Scripting Commands" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "Help TextEntry                            - Text Entry Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help Trigger                              - Trigger Commands" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "Help Unit                                 - Unit Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "Help World                                - World Commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      exitfunction
   endif
	
	rem help core
   if Script( slot , lin ).cmd = CMD_HELPCORE
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "SetConsoleSize                            - Sets the size of the Console" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "SetConsolePosition                        - Sets the position of the Console" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "OpenToRead <filename> <file index>        - Opens a file for reading" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "OpenToWrite <filename> <file index>       - Opens a file for writing" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CloseFile <file index>                    - closes a file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "ReadFileBlock <file index> <output file>  - reads a fileblock from the file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WriteFileBlock <file index> <input file>  - writes a fileblock to the file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WriteLong <file index> <integer>          - writes an integer value to the file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WriteFloat <file index> <float>           - writes a float to the file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WriteByte <file index> <byte>             - writes a byte to the file" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      exitfunction
   endif
   
   rem help game controls
   if Script( slot , lin ).cmd = CMD_HELPGAMECONTROLS
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CTRL_Button <value>                       - activates / deactivates button control" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CTRL_Camera <value>                       - activates / deactivates camera control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_ClickObj <value>                     - activates / deactivates click object control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Console <value>                      - activates / deactivates console control" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CTRL_Distortion <value>                   - activates / deactivates distortion control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_GUI <value>                          - activates / deactivates GUI control" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CTRL_Menu <value>                         - activates / deactivates menu commands" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Message <value>                      - activates / deactivates message control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Mouse <value>                        - activates / deactivates mouse control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Script <value>                       - activates / deactivates script control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Slider <value>                       - activates / deactivates slider control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_TextEntry <value>                    - activates / deactivates text input control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_Trigger <value>                      - activates / deactivates trigger control" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CTRL_Unit <value>                         - activates / deactivates unit control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_UnitBoxSelect <value>                - activates / deactivates unit boxing control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CTRL_World <value>                        - activates / deactivates world control" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      success = 1
   endif
	
	rem logging
	if Script( slot , lin ).cmd = CMD_HELPLOGGING
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "TurnAllLoggingOn                          - turns all logging on" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "TurnAllLoggingOff                         - turns all logging off" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CameraLogging <value>                     - activates / deactivates camera logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "ClickObjLogging <value>                   - activates / deactivates click object logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DistortionLogging <value>                 - activates / deactivates distortion logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUILogging <value>                        - activates / deactivates GUI logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "MenuLogging <value>                       - activates / deactivates menu logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "MessageLogging <value>                    - activates / deactivates message logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "TextEntryLogging <value>                  - activates / deactivates text entry logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "TriggerLogging <value>                    - activates / deactivates trigger logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitLogging <value>                       - activates / deactivates unit logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitBoxSelectLogging <value>              - activates / deactivates unit box select logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldLogging <value>                      - activates / deactivates world logging" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help camera
	if Script( slot , lin ).cmd = CMD_HELPCAMERA
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "SetCameraMode <value>                     - Sets the camera mode" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help click object
	if Script( slot , lin ).cmd = CMD_HELPCLICKOBJ
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateClickObj <x> <y> <z> <color> <life> - Creates a click object" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyClickObj <index>                   - Destroys a click object" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateClickObjConnection <index> <obj1> <obj2> - Creates a click object connection" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyClickObjConnection <index>         - Destroys a click object connection" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif

   rem help distortion
   if Script( slot , lin ).cmd = CMD_HELPDISTORTION
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "CreateDistortion <x> <y> <z> <bend> <bend_dec> <speed> <sector> - Creates a distortion" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "DestroyDistortion <index>                 - Distroys a distortion" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
      exitfunction
   endif
	
	rem help GUI
	if Script( slot , lin ).cmd = CMD_HELPGUI
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUIAddStaticImage <ID> <x> <y> <Filename>      - Adds a static image to the scene" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUIDestroyElement <ID>                         - Destroys a GUI element" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUIAddButton <ID> <x> <y> <KeyBind> <BackFile> <GlowFile> <PressFile> <LockedFile> - Creates a button" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUILockButton <ID>                             - Makes the button non clickable" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "GUIUnlockButton <ID>                           - Makes the button clickable" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif

   rem help menu
   if Script( slot , lin ).cmd = CMD_HELPMENU
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateSplash                              - Creates the splash screen" , 0xFFFFFF00 , 0 )
		AddtextToConsole( "DestroySplash                             - Destroys the splash screen", 0xFFFFFF00 , 0 )
      AddTextToConsole( "CreateMenu <Menu Index>                   - Creates a menu" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "DestroyMenu                               - Destroys the menu" , 0xFFFFFF00 , 0 )
      AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help message
	if Script( slot , lin ).cmd = CMD_HELPMESSAGE
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateMessage <x> <y> <life> <color> <text> - Creates a message to display on screen" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyMessage <index>                      - Destroys a message" , 0xFFFFFF00  , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help script
	if Script( slot , lin ).cmd = CMD_HELPSCRIPT
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "LoadScript <FileName> <Index>               - Loads a script" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "RunScript <Index>                           - Runs a script" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "StopScript <Index>                          - Stops a script" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help trigger
	if Script( slot , lin ).cmd = CMD_HELPTRIGGER
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreatePositionTrigger <x> <y> <z> <radius> <one_time_execute> <ScriptIndex> <ScriptFile> - Loads a script and binds it to a trigger" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateTimerTrigger <one_time_execute> <time> <ScriptIndex> <ScriptFile> - Loads a script and binds it to a trigger" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateUnitTimerTrigger <one_time_execute> <time> <ScriptIndex> <ScriptFile> - Loads a script and binds it to a unit trigger" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyTrigger <index>                      - Destroys a trigger" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "ShowTrigger <index>                         - Shows the boundaries of a trigger" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "ShowTriggers                                - Shows the boundaries of all triggers" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "HideTriggers                                - Hides the boundaries of all triggers" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help unit
	if Script( slot , lin ).cmd = CMD_HELPUNIT
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "CreateUnit <x> <y> <z> <control> <Filename> - creates a unit" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitAddAbility <ability> <ButtonID>         - Appends an ability to the last unit loaded" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyUnit <index>                         - destroys a unit" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitPosition <x> <y> <z>                    - Positions the unit" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitScale <x> <y> <z>                       - Scales the unit" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitLockAbility <ability>                   - Locks the button for that ability" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitUnlockAbility <ability>                 - Unlocks the button for that ability" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitSetAbilityRange <ability> <range>       - Sets the ability range" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitSetAbilityGlobal <ability>              - The ability only needs one click to activate all unist" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitSetAbilityLocal <ability>               - The ability will need one click per unit to activate" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitSetAbilityHealthDamage <ability> <value> - Sets the damage of this ability" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitSetAbilityManaDamage <ability> <value>  - Sets the mana damage of this ability" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitUseAbility <ability> <x> <z>            - Forces the unit to use an ability. X and Z for mouse click" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitBoxSelectEnable                         - enables box selecting of units" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitBoxSelectDisable                        - disables box selecting of units" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitDrawPath                                - enables path drawing for debug" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitHidePath                                - disables path drawing for debug" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitDrawFormation									- enables formation drawing for debug" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "UnitHideFormation									- disables formation drawing for debug" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem help world
	if Script( slot , lin ).cmd = CMD_HELPWORLD
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "DestroyWorld                                - Destroys the world" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldAddTerrainObject <Filename>            - Object file to add" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldCreatePathfinder <StartX> <StartY> <EndX> <EndY> <ResX> <ResY> <Threshold> <Filename>" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldShowPathmap                            - Shows the pathmap" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldHidePathmap                            - Hides the pathmap" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldCreateFogOfWar <StartX> <StartY> <EndX> <EndY> <ResX> <ResY> - Creates the world's fog of war" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "WorldDestroyFogOfWar                        - Destroys the fog of war" , 0xFFFFFF00 , 0 )
		AddTextToConsole( "===================================================" , 0xFFFFFF00 , 0 )
		exitfunction
	endif
	
	rem create click object
   if Script( slot , lin ).cmd = CMD_CREATECLICKOBJ
      success = CreateClickObj( ScriptFloatData(ScriptDataList(slot,lin,0)).dat , ScriptFloatData(ScriptDataList(slot,lin,1)).dat , ScriptFloatData(ScriptDataList(slot,lin,2)).dat , ScriptIntegerData(ScriptDataList(slot,lin,3)).dat , ScriptintegerData(ScriptDataList(slot,lin,4)).dat , 0 )
      AddTextToConsole( str$(success) + " = CreateClickObj " + str$(ScriptFloatData(ScriptDataList(slot,lin,0)).dat) + "," + str$(ScriptFloatData(ScriptDataList(slot,lin,1)).dat) + "," + str$(ScriptFloatData(ScriptDataList(slot,lin,2)).dat) + "," + str$(ScriptIntegerData(ScriptDataList(slot,lin,3)).dat) + "," + str$(ScriptintegerData(ScriptDataList(slot,lin,4)).dat) + ",0" , 0xFFFFFFFF , 0 )
      exitfunction
   endif
	
	remstart destroy click object
	if Script( slot , lin ).cmd = CMD_DESTROYCLICKOBJ
		success = DestroyClickObj( val(strings$(1)) )
		if success > -1 then AddTextToConsole( "DestroyClickObj " + strings$(1) , 0xFFFFFFFF , 0 )
		if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
      exitfunction
	endif
	
	rem create click object connection
	if strings$(0) = "createclickobjconnection " and success = 0
		if strings$(3) = ""
			AddTextToConsole( "CreateClickObjConnection expects <index> <obj1> <obj2>" , 0xFFFF0000 , 3 )
		else
			success = CreateClickObjConnection( val(strings$(1)) , val(strings$(2)) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateClickObjConnection " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy click object connection
	if strings$(0) = "destroyclickobjconnection " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "DestroyClickObjConnection expects <index>" , 0xFFFF0000 , 3 )
		else
			success = DestroyClickObjConnection( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "DestroyClickObjConnection " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create distortion
   if strings$(0) = "createdistortion " and success = 0
      if strings$(4) = ""
         AddTextToConsole("CreateDistortion Expects <x> <y> <z> <bend> <bend_dec> <speed> <sector>" , 0xFFFF0000 , 3 )
      else
         success = CreateDistortion( val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(5)) , val(strings$(6)) , val(strings$(7)) )
         if success > -1 then AddTextToConsole( str$(success) + " = CreateDistortion " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + strings$(5) + "," + strings$(6) + "," + strings$(7) , 0xFFFFFFFF , 0 )
         if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
      endif
      success = 1
   endif
   
   rem destroy distortion
   if strings$(0) = "destroydistortion " and success = 0
      if strings$(1) = ""
         AddTextToConsole("DestroyDistortion Expects <index>" , 0xFFFF0000 , 3 )
      else
         success = DestroyDistortion(val(strings$(1)))
         if success > -1 then AddTextToConsole( "DestroyDistortion" + strings$(1) , 0xFFFFFFFF , 0 )
         if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
      endif
      success = 1
   endif

	rem gui add static image
	if strings$(0) = "guiaddstaticimage " and success = 0
		if strings$(4) = ""
			AddTextToConsole( "GUIAddStaticImage expects <ID> <x> <y> <Filename>" , 0xFFFF0000 , 3 )
		else
			success = GUIAddStaticImage( left$( ComposeString( 4 , 30 ) , len(ComposeString( 4 , 30 )) - 1 ) , val(strings$(2)) , val(strings$(3)) , val(strings$(1)) )
			if success > -1 then AddTextToConsole( str$(success) + " = GUIAddStaticImage " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + ComposeString( 4 , 30 ) , 0xFFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem gui destroy element
	if strings$(0) = "guidestroyelement " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "GUIDestroyElement expects <ID>" , 0xFFFF0000 , 3 )
		else
			success = GUIDestroyElement( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "GUIDestroyElement " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem gui add button
	if strings$(0) = "guiaddbutton " and success = 0
		if strings$(8) = ""
			AddTextToConsole( "GUIAddButton expects <ID> <x> <y> <KeyBind> <File> <GlowFile> <PressFile> <LockedFile>" , 0xFFFF0000 , 3 )
		else
			success = GUIAddButton( left$(strings$(5),len(strings$(5))-1) , left$(strings$(6),len(strings$(6))-1) , left$(strings$(7),len(strings$(7))-1) , left$(strings$(8),len(strings$(8))-1) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(1)) )
			if success > -1 then AddTextToConsole( str$(success) + " = GUIAddButton " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + strings$(5) + "," + strings$(6) + "," + strings$(7) + "," + strings$(8) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem gui lock button
	if strings$(0) = "guilockbutton " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "GUILockButton expects <ID>" , 0xFFFF0000 , 3 )
		else
			success = GUILockButton( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "GUILockButton " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem gui unlock button
	if strings$(0) = "guiunlockbutton " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "GUIUnlockButton expects <ID>" , 0xFFFF0000 , 3 )
		else
			success = GUIUnlockButton( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "GUIUnlockButton " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem bind button to unit
	if strings$(0) = "guibindbuttontounit " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "GUIBindButtonToUnit expects <ID>" , 0xFFFF0000 , 3 )
		else
			success = GUIBindButtonToUnit( val(strings$(1)) , Unit.LastLoaded )
			if success > -1 then AddTextToConsole( "GUIBindButtonToUnit " + strings$(1) + "," + str$(Unit.LastLoaded) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem gui position button
	if strings$(0) = "guipositionbutton " and success = 0
		if strings$(3) = ""
			AddTextToConsole( "GUIPositionButton expects <ID> <x> <y>" , 0xFFFF0000 , 3 )
		else
			success = GUIPositionButton( val(strings$(1)) , val(strings$(2)) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( "GUIPositionButton " + strings$(1) + "," + strings$(2) + "," + strings$(3) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create splash
	if strings$(0) = "createsplash " and success = 0
		AddTextToConsole( "CreateSplash" , 0xFFFFFFFF , 0 )
		CreateSplash()
		success = 1
	endif
	
	rem destroy splash
	if strings$(0) = "destroysplash " and success = 0
		AddTextToConsole( "DestroySplash" , 0xFFFFFFFF , 0 )
		DestroySplash()
		success = 1
	endif

   rem create menu
   if strings$(0) = "createmenu " and success = 0
      if strings$(1) = ""
         AddTextToConsole("CreateMenu expects <value>" , 0xFFFF0000 , 3 )
      else
         CreateMenu( val(strings$(1)) )
         AddTextToConsole("CreateMenu " + strings$(1) , 0xFFFFFFFF , 0 )
      endif
      success = 1
   endif
   
   rem destroy menu
   if strings$(0) = "destroymenu " and success = 0
      DestroyMenu()
      AddTextToConsole("DestroyMenu" , 0xFFFFFFFF , 0 )
      success = 1
   endif
	
	rem create slider
	if strings$(0) = "createslider " and success = 0
		if strings$(6) = ""
			AddTextToConsole( "CreateSlider expects <x> <y> <min_value> <max_value> <current_value> <info>" , 0xFFFF0000 , 3 )
		else
			success = CreateSlider( val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(5)) , ComposeString( 6 , 30 ) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateSlider " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + strings$(5) + "," + ComposeString( 6 , 30 ) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy slider
	if strings$(0) = "destroyslider " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "DestroySlider expects <value>" , 0xFFFF0000 , 3 )
		else
			success = DestroySlider( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "DestroySlider " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create message
	if strings$(0) = "createmessage " and success = 0
		if strings$(5) = ""
			AddTextToConsole( "CreateMessage expects <x> <y> <life> <color> <text>" , 0xFFFF0000 , 3 )
		else
			success = CreateMessage( val(strings$(1)) , val(strings$(2)) , ComposeString( 5 , 30 ) , val(strings$(3)) , val(strings$(4)) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateMessage " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + ComposeString( 5 , 30 ) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy message
	if strings$(0) = "destroymessage " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "DestroyMessage expects <index>" , 0xFFFF0000 , 3 )
		else
			success = DestroyMessage( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "DestroyMessage " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create position trigger
	if strings$(0) = "createpositiontrigger " and success = 0
		if strings$(7) = ""
			AddTextToConsole("CreatePositionTrigger expects <x> <y> <z> <radius> <one_time_execute> <ScriptIndex> <ScriptFile>" , 0xFFFF0000 , 3 )
		else
			success = CreatePositionTrigger(val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(5)) , left$( strings$(6) , len( strings$(6)) - 1 ) , len(strings$(7)))
			if success > -1 then AddTextToConsole( str$(success) + " = CreateTrigger "+strings$(1)+","+strings$(2)+","+strings$(3)+","+strings$(4)+","+strings$(5)+","+strings$(6)+","+strings$(7) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create timer trigger
	if strings$(0) = "createtimertrigger " and success = 0
		if strings$(4) = ""
			AddTextToConsole( "CreateTimerTrigger expects <one_time_execute> <time> <ScriptIndex> <ScriptFile>" , 0xFFFF0000 , 3 )
		else
			success = CreateTimerTrigger( val(strings$(1)) , val(strings$(2)) , left$(ComposeString(4,30),len(ComposeString(4,30))-1) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateTimerTrigger " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + ComposeString(4,30) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Faild" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create unit timer trigger
	if strings$(0) = "createunittimertrigger " and success = 0
		if strings$(4) = ""
			AddTextToConsole( "CreateUnitTimerTrigger expects <one_time_execute> <time> <ScriptIndex> <ScriptFile>" , 0xFFFF0000 , 3 )
		else
			success = CreateUnitTimerTrigger( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) , left$(ComposeString(4,30),len(ComposeString(4,30))-1) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateUnitTimerTrigger " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + ComposeString(4,30) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy trigger
	if strings$(0) = "destroytrigger " and success = 0
		if strings$(1) = ""
			AddTextToConsole("DestroyTrigger expects <index>" , 0xFFFF0000 , 3 )
		else
			success = DestroyTrigger(val(strings$(1)))
			if success > -1 then AddTextToConsole( "DestroyTrigger "+strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem show trigger
	if strings$(0) = "showtrigger " and success = 0
		if strings$(1) = ""
			AddTextToConsole("ShowTrigger expects <index>" , 0xFFFF0000 , 3 )
		else
			success = ShowTrigger(val(strings$(1)))
			if success > -1 then AddTextToConsole( "ShowTrigger "+strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddtextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem hide triggers
	if strings$(0) = "hidetriggers " and success = 0
		HideTriggers()
		AddTextToConsole("HideTriggers" , 0xFFFFFFFF , 0 )
		success = 1
	endif
	
	rem show triggers
	if strings$(0) = "showtriggers " and success = 0
		ShowTriggers()
		AddTextToConsole("ShowTriggers" , 0xFFFFFFFF , 0 )
		success = 1
	endif
	
	rem create unit
	if strings$(0) = "createunit " and success = 0
		if strings$(5) = ""
			AddTextToConsole( "CreateUnit expects <x> <y> <z> <control> <Filename>" , 0xFFFF0000 , 3 )
		else
			success = CreateUnit( left$( ComposeString( 5 , 30 ) , len(ComposeString( 5 , 30 )) - 1 ) , val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) )
			if success > -1 then AddTextToConsole( str$(success) + " = CreateUnit " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + ComposeString( 5 , 30 ) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy unit
	if strings$(0) = "destroyunit " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "DestroyUnit expects <index>" , 0xFFFF0000 , 3 )
		else
			success = DestroyUnit( val(strings$(1)) )
			if success > -1 then AddTextToConsole( "DestroyUnit " + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem unit position
	if strings$(0) = "unitposition " and success = 0
		if strings$(3) = ""
			AddTextToConsole( "UnitPosition expects <x> <y> <z>" , 0xFFFF0000 , 3 )
		else
			success = UnitPosition( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( "UnitPosition " + str$(Unit.LastLoaded) + "," + str$(x#) + "," + str$(y#) + "," + str$(z#) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem unit scale
	if strings$(0) = "unitscale " and success = 0
		if strings$(3) = ""
			AddTextToConsole( "UnitScale expects <x%> <y%> <z%>" , 0xFFFF0000 , 0 )
		else
			success = UnitScale( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( "UnitScale " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) + "," + strings$(3) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem unit add parallax mapping
	if strings$(0) = "unitaddparallaxmapping " and success = 0
		if strings$(3) = ""
			AddTextToConsole( "UnitAddParallaxMapping expects <DiffuseFile> <NormalFile> <BumpFile>" , 0xFFFF0000 , 3 )
		else
			success = UnitAddParallaxMapping( Unit.LastLoaded , left$(strings$(1),len(strings$(1))-1) , left$(strings$(2),len(strings$(2))-1) , left$(strings$(3),len(strings$(3))-1) )
			if success > -1 then AddTextToConsole( "UnitAddParallaxMaping " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) + "," + strings$(3) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem enable unit box select
	if strings$(0) = "unitboxselectenable " and success = 0
		UnitBoxSelectEnable()
		AddTextToConsole( "UnitBoxSelectEnable" , 0xFFFFFFFF , 0 )
		success = 1
	endif
	
	rem disable unit box select
	if strings$(0) = "unitboxselectdisable " and success = 0
		UnitBoxSelectDisable()
		AddTextToConsole( "UnitBoxSelectDisable" , 0xFFFFFFFF , 0 )
		success = 1
	endif
	
	rem unit draw path
	if strings$(0) = "unitdrawpath " and success = 0
		AddTextToConsole( "UnitDrawPath" , 0xFFFFFFFF , 0 )
		Unit.DrawPath = 1
		success = 1
	endif
	
	rem unit hide path
	if strings$(0) = "unithidepath " and success = 0
		AddTextToConsole( "UnitHidePath" , 0xFFFFFFFF , 0 )
		Unit.DrawPath = 0
		success = 1
	endif
	
	rem unit draw formation
	if strings$(0) = "unitdrawformation " and success = 0
		AddTextToConsole( "UnitDrawFormation" , 0xFFFFFFFF , 0 )
		Unit.DrawFormation = 1
		success = 1
	endif
	
	rem unit hide formaiton
	if strings$(0) = "unithideformation " and success = 0
		AddTextToConsole( "UnitHideFormation" , 0xFFFFFFFF , 0 )
		Unit.DrawFormation = 0
		success = 1
	endif
	
	rem unit add ability
	if strings$(0) = "unitaddability " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "UnitAddAbility expects <ability> <ButtonID>" , 0xFFFF0000 , 3 )
		else
			success = UnitAddAbility( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) )
			if success > -1 then AddTextToConsole( "UnitAddAbility " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif

	rem set ability range
	if strings$(0) = "unitsetabilityrange " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "UnitSetAbilityRange expects <ability> <range>" , 0xFFFF0000 , 3 )
		else
			success = UnitSetAbilityRange( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) )
			if success > -1 then AddTextToConsole( "UnitSetAbilityRange " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem set ability global
	if strings$(0) = "unitsetabilityglobal " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitSetAbilityGlobal expects <ability>" , 0xFFFF0000 , 3 )
		else
			success = UnitSetAbilityGlobal( Unit.LastLoaded , val(strings$(1)) )
			if success > -1 then AddTextToConsole( "UnitSetAbilityGlobal " + str$(n) + "," + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem set ability local
	if strings$(0) = "unitsetabilitylocal " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitSetAbilityLocal expects <ability>" , 0xFFFF0000 , 3 )
		else
			success = UnitSetAbilityLocal( Unit.LastLoaded , val(strings$(1)) )
			if success > -1 then AddTextToConsole( "UnitSetAbilityLocal " + str$(n) + "," + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem use ability
	if strings$(0) = "unituseability " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitUseAbility expects <ability> <x> <z>" , 0xFFFF0000 , 3 )
		else
			success = UnitUseAbility( Unit.LastLoaded , val(strings$(1)) , val(strings$(2)) , val(strings$(3)) )
			if success > -1 then AddTextToConsole( "UnitUseAbility " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) + "," + strings$(3) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem set ability health damage
	if strings$(0) = "unitsetabilityhealthdamage " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "UnitSetAbilityHealthDamage expects <ability> <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "UnitSetAbilityHealthDamage " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			success = val(strings$(1))
			UnitAbility( Unit.LastLoaded , success ).HealthDamage# = val(strings$(2))
		endif
		success = 1
	endif
	
	rem set ability mana damage
	if strings$(0) = "UnitSetAbilityManaDamage " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "UnitSetAbilityManaDamage expects <ability> <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "UnitSetAbilityManaDamage " + str$(Unit.LastLoaded) + "," + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			success = val(strings$(1))
			UnitAbility( Unit.LastLoaded , success ).ManaDamage# = val(strings$(2))
		endif
		success = 1
	endif

	rem unit lock button
	if strings$(0) = "unitlockability " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitLockButton expects <ability>" , 0xFFFF0000 , 3 )
		else
			success = UnitLockAbility( Unit.LastLoaded , val(strings$(1)) )
			if success > -1 then AddTextToConsole( "UnitLockAbility " + str$(Unit.LastLoaded) + "," + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif

	rem unit unlock button
	if strings$(0) = "unitunlockability " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitUnlockButton expects <ability>" , 0xFFFF0000 , 3 )
		else
			success = UnitUnlockAbility( Unit.LastLoaded , val(strings$(1)) )
			if success > -1 then AddTextToConsole( "UnitUnlockAbility " + str$(Unit.LastLoaded) + "," + strings$(1) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem destroy world
	if strings$(0) = "destroyworld " and success = 0
		DestroyWorld()
		AddTextToConsole( "DestroyWorld" , 0xFFFFFFFF , 0 )
		success = 1
	endif
	
	rem add terrain object to world
	if strings$(0) = "worldaddterrainobject "
		if strings$(1) = ""
			AddTextToConsole( "WorldAddTerrainObject expects <Filename>" , 0xFFFF0000 , 3 )
		else
			success = WorldAddTerrainObject( left$( ComposeString( 1 , 30 ) , len(ComposeString( 1 , 30 )) - 1 ) )
			if success > -1 then AddTextToConsole( "WorldAddTerrainObject " + ComposeString( 1 , 30 ) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem add scenery object
	if strings$(0) = "worldaddsceneryobject "
		if strings$(1) = ""
			AddTextToConsole( "WorldAddSceneryObject expects <Filename>" , 0xFFFF0000 , 3 )
		else
			success = WorldAddSceneryObject( left$( ComposeString( 1 , 30 ) , len(ComposeString( 1 , 30 )) - 1 ) )
			if success > -1 then AddTextToConsole( "WorldAddSceneryObject " + ComposeString( 1 , 30 ) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem create pathfinder for world
	if strings$(0) = "worldcreatepathfinder " and success = 0
		if strings$(6) = ""
			AddTextToConsole( "WorldCreatePathfinder expects <StartX> <StartY> <EndX> <EndY> <ResX> <ResY> <Threshold> <Filename>" , 0xFFFF0000 , 3 )
		else
			success = WorldCreatePathfinder( left$( ComposeString( 8 , 30 ) , len(ComposeString( 8 , 30 )) - 1 ) , val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(5)) , val(strings$(6)) , val(strings$(7)) )
			if success > -1 then AddTextToConsole( "WorldCreatePathfinder " + ComposeString( 8 , 30 ) + "," + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + strings$(5) , 0xFFFFFFFF , 0 )
			if success = -1 then AddtextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem show pathmap
	if strings$(0) = "worldshowpathmap " and success = 0
		success = WorldShowPathmap()
		if success > -1 then AddTextToConsole( "WorldShowPathmap" , 0xFFFFFFFF , 0 )
		if success = -1 then AddTextToConsole( "Failed" , 0xFFFFFFFF , 3 )
		success = 1
	endif
	
	rem hide pathmap
	if strings$(0) = "worldhidepathmap " and success = 0
		success = WorldHidePathmap()
		if success > -1 then AddTextToConsole( "WorldHidePathmap" , 0xFFFFFFFF , 0 )
		if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		success = 1
	endif
	
	rem world create fog of war
	if strings$(0) = "worldcreatefogofwar " and success = 0
		if strings$(6) = ""
			AddTextToConsole( "WorldCreateFogOfWar expects <StartX> <StartY> <EndX> <EndY> <ResX> <ResY>" , 0xFFFF0000 , 3 )
		else
			success = WorldCreateFogOfWar( val(strings$(1)) , val(strings$(2)) , val(strings$(3)) , val(strings$(4)) , val(strings$(5)) , val(strings$(6)) )
			if success > -1 then AddTextToConsole( "WorldCreateFogOfWar " + strings$(1) + "," + strings$(2) + "," + strings$(3) + "," + strings$(4) + "," + strings$(5) + "," + strings$(6) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem world destroy fog of war
	if strings$(0) = "worlddestroyfogofwar " and success = 0
		success = WorldDestroyFogOfWar()
		if success > -1 then AddTextToConsole( "WorldDestroyFogOfWar" , 0xFFFFFFFF , 0 )
		if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		success = 1
	endif
	
	rem CTRL_Camera
	if strings$(0) = "ctrl_camera " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_Camera expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.Camera set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Camera = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_ClickObj
	if strings$(0) = "ctrl_clickobj " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_ClickObj expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.ClickObj set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.ClickObj = val(strings$(1))
		endif
		success = 1
	endif

	rem CTRL_Console
	if strings$(0) = "ctrl_console " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Console expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Console set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Console = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_Distortion
	if strings$(0) = "ctrl_distortion " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Distortion expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Distortion set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Distortion = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_GUI
	if strings$(0) = "ctrl_gui " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_GUI expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.GUI set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.GUI = val(strings$(1))
		endif
		success = 1
	endif

	rem CTRL_Menu
	if strings$(0) = "ctrl_menu " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Menu expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Menu set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Menu = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_Message
	if strings$(0) = "ctrl_message " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Message expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Message set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Message = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_Mouse
	if strings$(0) = "ctrl_mouse " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Mouse expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Mouse set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Mouse = val(strings$(1))
		endif
		success = 1
	endif

	rem CTRL_Script
	if strings$(0) = "ctrl_script " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Script expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Script set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Script = val(strings$(1))
		endif
		success = 1
	endif

	rem CTRL_Slider
	if strings$(0) = "ctrl_slider " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Slider expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Slider set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Slider = val(strings$(1))
		endif
		success = 1
	endif

	rem CTRL_TextEntry
	if strings$(0) = "ctrl_textentry " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_TextEntry expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.TextEntry set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.TextEntry = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_Trigger
	if strings$(0) = "ctrl_trigger " and success = 0
		if strings$(1) = ""
			AddTextToConsole("CTRL_Trigger expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("CTRL.Trigger set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Trigger = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_Unit
	if strings$(0) = "ctrl_unit " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_Unit expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.Unit set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.Unit = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_UnitBoxSelect
	if strings$(0) = "ctrl_unitboxselect " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_UnitBoxSelect expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.UnitBoxSelect set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.UnitBoxSelect = val(strings$(1))
		endif
		success = 1
	endif
	
	rem CTRL_World
	if strings$(0) = "ctrl_world " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CTRL_World expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "CTRL.World set to " + strings$(1) , 0xFF00FF00 , 0 )
			CTRL.World = val(strings$(1))
		endif
		success = 1
	endif

	rem turn all logging on
	if strings$(0) = "turnallloggingon " and success = 0
		AddTextToConsole("All logging flags enabled" , 0xFF00FF00 , 0 )
		SetAllLoggingFlags(1)
		success = 1
	endif
	
	rem turn all logging off
	if strings$(0) = "turnallloggingoff " and success = 0
		AddTextToConsole("All logging flags disabled" , 0xFF00FF00 , 0 )
		SetAllLoggingFlags(0)
		success = 1
	endif
	
	rem camera logging
	if strings$(0) = "cameralogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CameraLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "Camera.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Camera.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem click object logging
	if strings$(0) = "clickobjlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "ClickObjLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "ClickObj.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			ClickObj.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem distortion logging
	if strings$(0) = "distortionlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole("DistortionLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("Distortion.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Distortion.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem gui logging
	if strings$(0) = "guilogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "GUILogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "GUI.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			GUI.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem menu logging
	if strings$(0) = "menulogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole("MenuLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("Menu.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Menu.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem message logging
	if strings$(0) = "messagelogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole("MessageLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("Message.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Message.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem trigger logging
	if strings$(0) = "triggerlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole("TriggerLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole("Trigger.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Trigger.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem unit logging
	if strings$(0) = "unitlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "Unit.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			Unit.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem unit box select logging
	if strings$(0) = "unitboxselectlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "UnitBoxSelectLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "UnitBoxSelect.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			UnitBoxSelect.logging = val(strings$(1))
		endif
		success = 1
	endif
	
	rem world logging
	if strings$(0) = "worldlogging " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "WorldLogging expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "World.logging set to " + strings$(1) , 0xFF00FF00 , 0 )
			World.logging = val(strings$(1))
		endif
		success = 1
	endif

   rem set Console size
   if strings$(0) = "setconsolesize " and success = 0
      if strings$(1) = ""
         show mouse
         Console.resize = 1
      endif
      success = 1
   endif
   
   rem set Console position
   if strings$(0) = "setconsoleposition " and success = 0
      if strings$(1) = ""
         show mouse
         Console.move = 1
      endif
      success = 1
   endif
	
	rem open file for writing
	if strings$(0) = "opentowrite " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "OpenToWrite expects <file> <filename>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) )
				AddTextToConsole( "File " + strings$(1) + "already open!" ,0xFFFF0000 , 3 )
			else
				OpenToWrite( val(strings$(1)) , left$( strings$(2) , len(strings$(2)) - 1 ) )
			endif
		endif
		success = 1
	endif
	
	rem open file for reading
	if strings$(0) = "opentoread " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "OpenToRead expects <file> <filename>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) )
				AddTextToConsole( "File " + strings$(1) + "already open!" , 0xFFFF0000 , 3 )
			else
				OpenToRead( val(strings$(1)) , left$( strings$(2) , len(strings$(2)) - 1 ) )
			endif
		endif
		success = 1
	endif
	
	rem close file
	if strings$(0) = "closefile " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "CloseFile expects <file>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "already closed!" , 0xFFFF0000 , 3 )
			else
				close file val(strings$(1))
				AddTextToConsole( "CloseFile " + strings$(1) , 0xFFFFFFFF , 0 )
			endif
		endif
		success = 1
	endif
	
	rem read fileblock
	if strings$(0) = "readfileblock " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "ReadFileBlock expects <file> <outFilename>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "not open!" , 0xFFFF0000 , 3 )
			else
				read fileblock val(strings$(1)) , left$( strings$(2) , len(strings$(2)) - 1 )
				AddTextToConsole( "ReadFileBlock " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			endif
		endif
		success = 1
	endif
	
	rem write fileblock
	if strings$(0) = "writefileblock " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "WriteFileBlock expects <file> <inFilename>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "not open!" , 0xFFFF0000 , 3 )
			else
				if file exist( left$( strings$(2) , len(strings$(2)) - 1 ) ) = 0
					AddTextToConsole( "File " + strings$(2) + "does not exist!" , 0xFFFF0000 , 3 )
				else
					write fileblock val(strings$(1)) , left$( strings$(2) , len(strings$(2)) - 1 )
					AddTextToConsole( "WriteFileBlock " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
				endif
			endif
		endif
		success = 1
	endif
	
	rem write byte
	if strings$(0) = "writebyte " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "WriteByte expects <file> <byte>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "not open!" , 0xFFFF0000 , 3 )
			else
				write byte val(strings$(1)) , val(strings$(2))
				AddTextToConsole( "WriteByte " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			endif
		endif
		success = 1
	endif
	
	rem write long
	if strings$(0) = "writelong " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "WriteLong expects <file> <integer>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "not open!" , 0xFFFF0000 , 3 )
			else
				write long val(strings$(1)) , val(strings$(2))
				AddTextToConsole( "WriteLong " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			endif
		endif
		success = 1
	endif
	
	rem write float
	if strings$(0) = "writefloat " and success = 0
		if strings$(2) = ""
			AddTextToConsole( "WriteFloat expects <file> <float>" , 0xFFFF0000 , 3 )
		else
			if file open( val(strings$(1)) ) = 0
				AddTextToConsole( "File " + strings$(1) + "not open!" , 0xFFFF0000 , 3 )
			else
				write float val(strings$(1)) , val(strings$(2))
				AddTextToConsole( "WriteFloat " + strings$(1) + "," + strings$(2) , 0xFFFFFFFF , 0 )
			endif
		endif
		success = 1
	endif
	
	rem set variables
	if strings$(0) = "setvalue " and success = 0
		
		AddTextToConsole( "SetValue " + strings$(1) + strings$(2) , 0xFFFFFFFF , 0 )
		
		rem unit keyframes
		if strings$(1) = "unit.anim.idle.start " then Unit( Unit.LastLoaded ).Anim.Idle.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.idle.end " then Unit( Unit.LastLoaded ).Anim.Idle.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.creep.start " then Unit( Unit.LastLoaded ).Anim.Creep.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.creep.end " then Unit( Unit.LastLoaded ).Anim.Creep.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.walk.start " then Unit( Unit.LastLoaded ).Anim.Walk.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.walk.end " then Unit( Unit.LastLoaded ).Anim.Walk.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.run.start " then Unit( Unit.LastLoaded ).Anim.Run.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.run.end " then Unit( Unit.LastLoaded ).Anim.Run.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffjump.start " then Unit( Unit.LastLoaded ).Anim.TakeOffJump.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffjump.end " then Unit( Unit.LastLoaded ).Anim.TakeOffJump.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffflyup.start " then Unit( Unit.LastLoaded ).Anim.TakeOffFlyUp.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffflyup.end " then Unit( Unit.LastLoaded ).Anim.TakeOffFlyUp.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffarrivetop.start " then Unit( Unit.LastLoaded ).Anim.TakeOffArriveTop.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffarrivetop.end " then Unit( Unit.LastLoaded ).Anim.TakeOffArriveTop.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.fly.start " then Unit( Unit.LastLoaded ).Anim.Fly.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.fly.end " then Unit( Unit.LastLoaded ).Anim.Fly.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidle.start " then Unit( Unit.LastLoaded ).Anim.FlyIdle.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidle.end " then Unit( Unit.LastLoaded ).Anim.FlyIdle.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidletofly.start " then Unit( Unit.LastLoaded ).Anim.FlyIdleToFly.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidletofly.end " then Unit( Unit.LastLoaded ).Anim.FlyIdleToFly.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flytoflyidle.start " then Unit( Unit.LastLoaded ).Anim.FlyToFlyIdle.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flytoflyidle.end " then Unit( Unit.LastLoaded ).Anim.FlyToFlyIdle.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landprepare.start " then Unit( Unit.LastLoaded ).Anim.LandPrepare.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landprepare.end " then Unit( Unit.LastLoaded ).Anim.LandPrepare.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landflydown.start " then Unit( Unit.LastLoaded ).Anim.LandFlyDown.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landflydown.end " then Unit( Unit.LastLoaded ).Anim.LandFlyDown.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landarrivebottom.start " then Unit( Unit.LastLoaded ).Anim.LandArriveBottom.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landarrivebottom.end " then Unit( Unit.LastLoaded ).Anim.LandArriveBottom.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie1.start " then Unit( Unit.LastLoaded ).Anim.GroundDie1.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie1.end " then Unit( Unit.LastLoaded ).Anim.GroundDie1.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie2.start " then Unit( Unit.LastLoaded ).Anim.GroundDie2.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie2.end " then Unit( Unit.LastLoaded ).Anim.GroundDie2.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddieburn.start " then Unit( Unit.LastLoaded ).Anim.GroundDieBurn.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddieburn.end " then Unit( Unit.LastLoaded ).Anim.GroundDieBurn.mEnd = val(strings$(2)) : success = 1
		
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare1.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare1.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare1.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare1.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare2.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare2.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare2.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare2.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare3.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare3.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare3.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare3.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease1.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease1.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease1.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease1.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease2.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease2.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease2.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease2.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease3.start " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease3.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease3.end " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease3.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare1.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare1.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare1.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare1.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare2.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare2.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare2.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare2.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare3.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare3.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare3.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare3.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease1.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease1.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease1.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease1.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease2.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease2.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease2.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease2.mEnd = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease3.start " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease3.mStart = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease3.end " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease3.mEnd = val(strings$(2)) : success = 1
		
		rem unit frame speeds
		if strings$(1) = "unit.anim.idle.speed " then Unit( Unit.LastLoaded ).Anim.Idle.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.creep.speed " then Unit( Unit.LastLoaded ).Anim.Creep.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.walk.speed " then Unit( Unit.LastLoaded ).Anim.Walk.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.run.speed " then Unit( Unit.LastLoaded ).Anim.Run.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffjump.speed " then Unit( Unit.LastLoaded ).Anim.TakeOffJump.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffflyup.speed " then Unit( Unit.LastLoaded ).Anim.TakeOffFlyUp.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.takeoffarrivetop.speed " then Unit( Unit.LastLoaded ).Anim.TakeOffArriveTop.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.fly.speed " then Unit( Unit.LastLoaded ).Anim.Fly.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidle.speed " then Unit( Unit.LastLoaded ).Anim.FlyIdle.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flytoflyidle.speed " then Unit( Unit.LastLoaded ).Anim.FlyToFlyIdle.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.flyidletofly.speed " then Unit( Unit.LastLoaded ).Anim.FlyIdleToFly.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landprepare.speed " then Unit( Unit.LastLoaded ).Anim.LandPrepare.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landflydown.speed " then Unit( Unit.LastLoaded ).Anim.LandFlyDown.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.landarrivebottom.speed " then Unit( Unit.LastLoaded ).Anim.LandArriveBottom.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie1.speed " then Unit( Unit.LastLoaded ).Anim.GroundDie1.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddie2.speed " then Unit( Unit.LastLoaded ).Anim.GroundDie2.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.grounddieburn.speed " then Unit( Unit.LastLoaded ).Anim.GroundDieBurn.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare1.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare1.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare2.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare2.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackprepare3.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackPrepare3.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease1.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease1.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease2.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease2.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.unicorngroundmagicattackrelease3.speed " then Unit( Unit.LastLoaded ).Anim.UnicornGroundMagicAttackRelease3.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare1.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare1.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare2.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare2.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackprepare3.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackPrepare3.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease1.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease1.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease2.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease2.mSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.anim.changelinggroundmeleeattackrelease3.speed " then Unit( Unit.LastLoaded ).Anim.ChangelingGroundMeleeAttackRelease3.mSpeed# = val(strings$(2)) : success = 1
		
		rem unit speeds
		if strings$(1) = "unit.groundspeed " then Unit( Unit.LastLoaded ).GroundSpeed# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.airspeed " then Unit( Unit.LastLoaded ).AirSpeed# = val(strings$(2)) : success = 1
		
		rem unit ranges
		if strings$(1) = "unit.groundviewrange " then Unit( Unit.LastLoaded ).GroundViewRange# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.airviewrange " then Unit( Unit.LastLoaded ).AirViewRange# = val(strings$(2)) : success = 1
		
		rem unit stats
		if strings$(1) = "unit.stats.healthenable " then Unit( Unit.LastLoaded ).Stats.HealthEnable = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.manaenable " then Unit( Unit.LastLoaded ).Stats.ManaEnable = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.shieldenable " then Unit( Unit.LastLoaded ).Stats.ShieldEnable = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.maxhealth " then Unit( Unit.LastLoaded ).Stats.MaxHealth = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.currenthealth " then Unit( Unit.LastLoaded ).Stats.CurrentHealth# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.maxmana " then Unit( Unit.LastLoaded ).Stats.MaxMana = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.currentmana " then Unit( Unit.LastLoaded ).Stats.CurrentMana# = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.maxshield " then Unit( Unit.LastLoaded ).Stats.MaxShield = val(strings$(2)) : success = 1
		if strings$(1) = "unit.stats.currentshield " then Unit( Unit.LastLoaded ).Stats.CurrentShield# = val(strings$(2)) : success = 1
		
		rem limbs
		if strings$(1) = "unit.spellcastlimb " then Unit( Unit.LastLoaded ).SpellCastLimb = val(strings$(2)) : success = 1
		
		rem ability settings
		if strings$(1) = "unit.ability.automatic " then Unit( Unit.LastLoaded ).Ability.Automatic = val(strings$(2)) : success = 1
		
		rem camera values
		if strings$(1) = "camera.maxpos.x " then Camera.MaxPos.x# = val(strings$(2)) : success = 1
		if strings$(1) = "camera.maxpos.z " then Camera.MaxPos.z# = val(strings$(2)) : success = 1
		if strings$(1) = "camera.minpos.x " then Camera.MinPos.x# = val(strings$(2)) : success = 1
		if strings$(1) = "camera.minpos.z " then Camera.MinPos.z# = val(strings$(2)) : success = 1
		
		rem world values
		if strings$(1) = "world.fogofwar.fadespeed " then World.FogOfWar.FadeSpeed = val(strings$(2)) : success = 1
		
	endif
	
	rem force output
	if strings$(0) = "forceoutput " and success = 0
		if strings$(1) = ""
			AddTextToConsole( "ForceOutput expects <value>" , 0xFFFF0000 , 3 )
		else
			AddTextToConsole( "Console.ForceOutput set to " + strings$(1) , 0xFF00FF00 , 0 )
			Console.ForceOutput = val(strings$(1))
		endif
		success = 1
	endif
			

	rem load script
	if strings$(0) = "loadscript " and success = 0
		if strings$(2) = ""
			AddTextToConsole("LoadScript expects <filename> <index>" , 0xFFFF0000 , 3 )
		else
		   success = LoadScript( left$( strings$(1) , len( strings$(1)) ) , val(strings$(2)))
			if success > -1 then AddTextToConsole( "LoadScript "+strings$(1)+","+strings$(2) , 0xFFFFFFFF , 0 )
			if success = -1 then AddTextToConsole( "Failed" , 0xFFFF0000 , 3 )
		endif
		success = 1
	endif
	
	rem run script
	if strings$(0) = "runscript " and success = 0
		if strings$(1) = ""
			AddTextToConsole("RunScript expects <index>" , 0xFFFF0000 , 3 )
		else
			RunScript(val(strings$(1)))
			AddTextToConsole("RunScript "+strings$(1) , 0xFFFFFFFF , 0 )
		endif
		success = 1
	endif
	
	rem stop script
	if strings$(0) = "stopscript " and success = 0
		if strings$(1) = ""
			AddTextToConsole("StopScript expects <index>" , 0xFFFF0000 , 3 )
		else
			StopScript(val(strings$(1)))
			AddTextToConsole("StopScript "+strings$(1) , 0xFFFFFFFF , 0 )
		endif
		success = 1
	endif
	
	rem end script
	if strings$(0) = "end " and success = 0
		Script(Script.CurrentSelected).Active = 1
		success = 1
	endif
	
	rem end program
	if strings$(0) = "endprogram " and success = 0
		end
	endif
	
	rem disable iteration
	if strings$(0) = "disableiteration " then success = 1
	
	remend
   
   rem unable to execute
   AddTextToConsole( "Unknown OP code! -- " + chr$(34) + val(Script( slot , lin ).cmd) + chr$(34) , 0xFFFF0000 , 4 )
   AddTextToConsole( "Script: " + val(slot) , 0xFFFF0000 , 4 )
   AddTextToConsole( "line: " + val(lin) , 0xFFFF0000 , 4 )

endfunction
rem ---------------------------------------------------------------------------
rem Text Entry - Handles the input buffer
rem ---------------------------------------------------------------------------

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant TEXTENTRY_NUMBERS                  1
#constant TEXTENTRY_CHARACTERS               2
#constant TEXTENTRY_ALL                      3

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type TextEntryVT
   Char$                                     as string
   Buffer$                                   as string
   ThisEntry$                                as string
   Cursor                                    as integer
   Cursor$                                   as string
   Mode                                      as integer
   CharLimit                                 as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitTextEntry()

	rem debug
	DebugOutput( 0 , "Initialising TextEntry" )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global TextEntry                            as TextEntryVT
	
	rem initial values
	TextEntry.Cursor = hitimer( 1000 )
	TextEntry.Mode = TEXTENTRY_ALL
	TextEntry.CharLimit = 255

endfunction

function ClearTextEntry()

   rem clear buffer and entry
   clear entry buffer
   TextEntry.Buffer$ = ""
   TextEntry.ThisEntry$ = ""
   
endfunction

function SetTextEntryMode( mode )

   rem store mode
   TextEntry.Mode = mode
   
endfunction

function SetTextEntryCharacterLimit( CharLimit )

   rem store character limit
   TextEntry.CharLimit = CharLimit
   
endfunction

function GetTextEntryWithCursor()

   rem return text entry with cursor
   return$ = TextEntry.ThisEntry$ + TextEntry.Cursor$
   
endfunction return$

function GetTextEntry()

   rem return text entry without cursor
   return$ = TextEntry.ThisEntry$
   
endfunction return$

function ControlTextEntry()

   rem local variables
   local n as integer
   local v as integer

   rem control blinking cursor, 400ms
   if hitimer( 1000 ) - TextEntry.Cursor > 400
      TextEntry.Cursor$ = "|"
      if hitimer( 1000 ) - TextEntry.Cursor > 800
         TextEntry.Cursor$ = ""
         TextEntry.Cursor = hitimer( 1000 )
      endif
   endif
   
   rem read in entry buffer
   TextEntry.Buffer$ = entry$()
   clear entry buffer
   
   rem process buffer
   for n = 1 to len( TextEntry.Buffer$ )
   
      rem if entry was made, reset cursor
      TextEntry.Cursor$ = "|"
      TextEntry.Cursor = hitimer( 1000 )
   
      rem process each character in buffer separately
      TextEntry.Char$ = mid$( TextEntry.Buffer$ , n )
      v = asc( TextEntry.Char$ )
      
      rem backspace
      if v = 8 then TextEntry.ThisEntry$ = left$( TextEntry.ThisEntry$ , len( TextEntry.ThisEntry$ ) - 1 )
      
      rem make sure length limit hasn't been reached
      if TextEntry.CharLimit > len( TextEntry.ThisEntry$ )
      
         rem get only numbers
         if TextEntry.Mode = TEXTENTRY_NUMBERS or TextEntry.Mode = TEXTENTRY_ALL
            if v > 47 and v < 58
               TextEntry.ThisEntry$ = TextEntry.ThisEntry$ + TextEntry.Char$
            endif
         endif
         
         rem get only characters
         if TextEntry.Mode = TEXTENTRY_CHARACTERS or TextEntry.Mode = TEXTENTRY_ALL
            if v > 31 and (v < 48 or v > 57)
               TextEntry.ThisEntry$ = TextEntry.ThisEntry$ + TextEntry.Char$
            endif
         endif
         
      endif
      
   next n

endfunction
